
build/f4audio.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  1 .text         00002114  08000000  08000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .data         00000008  20000000  08002358  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          00004300  20000008  08002360  00020008  2**2
                  ALLOC

Disassembly of section .text:

08000000 <___SVECTOR>:
 8000000:	20050000 	.word	0x20050000
 8000004:	08000299 	.word	0x08000299
 8000008:	080002e5 	.word	0x080002e5
 800000c:	080002e5 	.word	0x080002e5
 8000010:	080002e5 	.word	0x080002e5
 8000014:	080002e5 	.word	0x080002e5
 8000018:	080002e5 	.word	0x080002e5
	...
 800002c:	080002e5 	.word	0x080002e5
 8000030:	080002e5 	.word	0x080002e5
 8000034:	00000000 	.word	0x00000000
 8000038:	080002e5 	.word	0x080002e5
 800003c:	08000551 	.word	0x08000551
 8000040:	080002e5 	.word	0x080002e5
 8000044:	080002e5 	.word	0x080002e5
 8000048:	080002e5 	.word	0x080002e5
 800004c:	080002e5 	.word	0x080002e5
 8000050:	080002e5 	.word	0x080002e5
 8000054:	080002e5 	.word	0x080002e5
 8000058:	080002e5 	.word	0x080002e5
 800005c:	080002e5 	.word	0x080002e5
 8000060:	080002e5 	.word	0x080002e5
 8000064:	080002e5 	.word	0x080002e5
 8000068:	080002e5 	.word	0x080002e5
 800006c:	080002e5 	.word	0x080002e5
 8000070:	080002e5 	.word	0x080002e5
 8000074:	080002e5 	.word	0x080002e5
 8000078:	080002e5 	.word	0x080002e5
 800007c:	080002e5 	.word	0x080002e5
 8000080:	080002e5 	.word	0x080002e5
 8000084:	080002e5 	.word	0x080002e5
 8000088:	0800064d 	.word	0x0800064d
 800008c:	080002e5 	.word	0x080002e5
 8000090:	080002e5 	.word	0x080002e5
 8000094:	080002e5 	.word	0x080002e5
 8000098:	080002e5 	.word	0x080002e5
 800009c:	080002e5 	.word	0x080002e5
 80000a0:	080002e5 	.word	0x080002e5
 80000a4:	080002e5 	.word	0x080002e5
 80000a8:	080002e5 	.word	0x080002e5
 80000ac:	080002e5 	.word	0x080002e5
 80000b0:	080002e5 	.word	0x080002e5
 80000b4:	080002e5 	.word	0x080002e5
 80000b8:	080002e5 	.word	0x080002e5
 80000bc:	080002e5 	.word	0x080002e5
 80000c0:	080002e5 	.word	0x080002e5
 80000c4:	080002e5 	.word	0x080002e5
 80000c8:	080002e5 	.word	0x080002e5
 80000cc:	080002e5 	.word	0x080002e5
 80000d0:	080002e5 	.word	0x080002e5
 80000d4:	080002e5 	.word	0x080002e5
 80000d8:	080002e5 	.word	0x080002e5
 80000dc:	08001025 	.word	0x08001025
 80000e0:	080002e5 	.word	0x080002e5
 80000e4:	080002e5 	.word	0x080002e5
 80000e8:	080002e5 	.word	0x080002e5
 80000ec:	080002e5 	.word	0x080002e5
 80000f0:	080002e5 	.word	0x080002e5
 80000f4:	080002e5 	.word	0x080002e5
 80000f8:	080002e5 	.word	0x080002e5
 80000fc:	080002e5 	.word	0x080002e5
 8000100:	080002e5 	.word	0x080002e5
 8000104:	080002e5 	.word	0x080002e5
 8000108:	080002e5 	.word	0x080002e5
 800010c:	080002e5 	.word	0x080002e5
 8000110:	080002e5 	.word	0x080002e5
 8000114:	080002e5 	.word	0x080002e5
 8000118:	080002e5 	.word	0x080002e5
 800011c:	080002e5 	.word	0x080002e5
 8000120:	080002e5 	.word	0x080002e5
 8000124:	080002e5 	.word	0x080002e5
 8000128:	080002e5 	.word	0x080002e5
 800012c:	080002e5 	.word	0x080002e5
 8000130:	080002e5 	.word	0x080002e5
 8000134:	080002e5 	.word	0x080002e5
 8000138:	080002e5 	.word	0x080002e5
 800013c:	080002e5 	.word	0x080002e5
 8000140:	080002e5 	.word	0x080002e5
 8000144:	080002e5 	.word	0x080002e5
 8000148:	080002e5 	.word	0x080002e5
 800014c:	080002e5 	.word	0x080002e5
 8000150:	080002e5 	.word	0x080002e5
 8000154:	080002e5 	.word	0x080002e5
 8000158:	080002e5 	.word	0x080002e5
 800015c:	080002e5 	.word	0x080002e5
 8000160:	080002e5 	.word	0x080002e5
 8000164:	080002e5 	.word	0x080002e5
 8000168:	080002e5 	.word	0x080002e5
 800016c:	080002e5 	.word	0x080002e5
 8000170:	080002e5 	.word	0x080002e5
 8000174:	080002e5 	.word	0x080002e5
 8000178:	080002e5 	.word	0x080002e5
 800017c:	00000000 	.word	0x00000000
 8000180:	080002e5 	.word	0x080002e5
 8000184:	080002e5 	.word	0x080002e5
 8000188:	080002e5 	.word	0x080002e5
 800018c:	080002e5 	.word	0x080002e5
 8000190:	080002e5 	.word	0x080002e5
 8000194:	080002e5 	.word	0x080002e5
 8000198:	080002e5 	.word	0x080002e5
 800019c:	080002e5 	.word	0x080002e5
 80001a0:	080002e5 	.word	0x080002e5
 80001a4:	080002e5 	.word	0x080002e5
 80001a8:	080002e5 	.word	0x080002e5
 80001ac:	080002e5 	.word	0x080002e5
 80001b0:	080002e5 	.word	0x080002e5
 80001b4:	080002e5 	.word	0x080002e5
 80001b8:	080002e5 	.word	0x080002e5
 80001bc:	080002e5 	.word	0x080002e5
 80001c0:	080002e5 	.word	0x080002e5
 80001c4:	080002e5 	.word	0x080002e5

080001c8 <memset>:
 80001c8:	b500      	push	{lr}
 80001ca:	4603      	mov	r3, r0
 80001cc:	f361 210f 	bfi	r1, r1, #8, #8
 80001d0:	f361 411f 	bfi	r1, r1, #16, #16
 80001d4:	f012 0f01 	tst.w	r2, #1
 80001d8:	d004      	beq.n	80001e4 <.memset1>
 80001da:	7019      	strb	r1, [r3, #0]
 80001dc:	f103 0301 	add.w	r3, r3, #1
 80001e0:	f1a2 0201 	sub.w	r2, r2, #1

080001e4 <.memset1>:
 80001e4:	f012 0f02 	tst.w	r2, #2
 80001e8:	d004      	beq.n	80001f4 <.memset2>
 80001ea:	8019      	strh	r1, [r3, #0]
 80001ec:	f103 0302 	add.w	r3, r3, #2
 80001f0:	f1a2 0202 	sub.w	r2, r2, #2

080001f4 <.memset2>:
 80001f4:	2a00      	cmp	r2, #0
 80001f6:	d004      	beq.n	8000202 <.memset_end>

080001f8 <.memset4>:
 80001f8:	6019      	str	r1, [r3, #0]
 80001fa:	f103 0304 	add.w	r3, r3, #4
 80001fe:	3a04      	subs	r2, #4
 8000200:	d1fa      	bne.n	80001f8 <.memset4>

08000202 <.memset_end>:
 8000202:	bd00      	pop	{pc}

08000204 <memcpy>:
 8000204:	2a00      	cmp	r2, #0
 8000206:	bf08      	it	eq
 8000208:	4770      	bxeq	lr
 800020a:	b501      	push	{r0, lr}
 800020c:	2a20      	cmp	r2, #32
 800020e:	d220      	bcs.n	8000252 <.memcpy_opt>

08000210 <.memcpy_unalign>:
 8000210:	f012 0f01 	tst.w	r2, #1
 8000214:	d007      	beq.n	8000226 <.memcpy1>
 8000216:	780b      	ldrb	r3, [r1, #0]
 8000218:	7003      	strb	r3, [r0, #0]
 800021a:	f100 0001 	add.w	r0, r0, #1
 800021e:	f101 0101 	add.w	r1, r1, #1
 8000222:	f1a2 0201 	sub.w	r2, r2, #1

08000226 <.memcpy1>:
 8000226:	f012 0f02 	tst.w	r2, #2
 800022a:	d007      	beq.n	800023c <.memcpy2>
 800022c:	880b      	ldrh	r3, [r1, #0]
 800022e:	8003      	strh	r3, [r0, #0]
 8000230:	f100 0002 	add.w	r0, r0, #2
 8000234:	f101 0102 	add.w	r1, r1, #2
 8000238:	f1a2 0202 	sub.w	r2, r2, #2

0800023c <.memcpy2>:
 800023c:	2a00      	cmp	r2, #0
 800023e:	d007      	beq.n	8000250 <.memcpy_end>

08000240 <.memcpy4>:
 8000240:	680b      	ldr	r3, [r1, #0]
 8000242:	6003      	str	r3, [r0, #0]
 8000244:	f100 0004 	add.w	r0, r0, #4
 8000248:	f101 0104 	add.w	r1, r1, #4
 800024c:	3a04      	subs	r2, #4
 800024e:	d1f7      	bne.n	8000240 <.memcpy4>

08000250 <.memcpy_end>:
 8000250:	bd01      	pop	{r0, pc}

08000252 <.memcpy_opt>:
 8000252:	ea80 0301 	eor.w	r3, r0, r1
 8000256:	f013 0f03 	tst.w	r3, #3
 800025a:	d1d9      	bne.n	8000210 <.memcpy_unalign>
 800025c:	f010 0f01 	tst.w	r0, #1
 8000260:	d007      	beq.n	8000272 <.memcpy_opt1>
 8000262:	780b      	ldrb	r3, [r1, #0]
 8000264:	7003      	strb	r3, [r0, #0]
 8000266:	f100 0001 	add.w	r0, r0, #1
 800026a:	f101 0101 	add.w	r1, r1, #1
 800026e:	f1a2 0201 	sub.w	r2, r2, #1

08000272 <.memcpy_opt1>:
 8000272:	f010 0f02 	tst.w	r0, #2
 8000276:	d007      	beq.n	8000288 <.memcpy_opt16_i>
 8000278:	880b      	ldrh	r3, [r1, #0]
 800027a:	8003      	strh	r3, [r0, #0]
 800027c:	f100 0002 	add.w	r0, r0, #2
 8000280:	f101 0102 	add.w	r1, r1, #2
 8000284:	f1a2 0202 	sub.w	r2, r2, #2

08000288 <.memcpy_opt16_i>:
 8000288:	b470      	push	{r4, r5, r6}

0800028a <.memcpy_opt16>:
 800028a:	c978      	ldmia	r1!, {r3, r4, r5, r6}
 800028c:	c078      	stmia	r0!, {r3, r4, r5, r6}
 800028e:	3a10      	subs	r2, #16
 8000290:	2a10      	cmp	r2, #16
 8000292:	d2fa      	bcs.n	800028a <.memcpy_opt16>
 8000294:	bc70      	pop	{r4, r5, r6}
 8000296:	e7bb      	b.n	8000210 <.memcpy_unalign>

08000298 <Reset_Handler>:
 8000298:	f8df d030 	ldr.w	sp, [pc, #48]	; 80002cc <LoopFillZerobss+0x10>
 800029c:	2100      	movs	r1, #0
 800029e:	e003      	b.n	80002a8 <LoopCopyDataInit>

080002a0 <CopyDataInit>:
 80002a0:	4b0b      	ldr	r3, [pc, #44]	; (80002d0 <LoopFillZerobss+0x14>)
 80002a2:	585b      	ldr	r3, [r3, r1]
 80002a4:	5043      	str	r3, [r0, r1]
 80002a6:	3104      	adds	r1, #4

080002a8 <LoopCopyDataInit>:
 80002a8:	480a      	ldr	r0, [pc, #40]	; (80002d4 <LoopFillZerobss+0x18>)
 80002aa:	4b0b      	ldr	r3, [pc, #44]	; (80002d8 <LoopFillZerobss+0x1c>)
 80002ac:	1842      	adds	r2, r0, r1
 80002ae:	429a      	cmp	r2, r3
 80002b0:	d3f6      	bcc.n	80002a0 <CopyDataInit>
 80002b2:	4a0a      	ldr	r2, [pc, #40]	; (80002dc <LoopFillZerobss+0x20>)
 80002b4:	e002      	b.n	80002bc <LoopFillZerobss>

080002b6 <FillZerobss>:
 80002b6:	2300      	movs	r3, #0
 80002b8:	f842 3b04 	str.w	r3, [r2], #4

080002bc <LoopFillZerobss>:
 80002bc:	4b08      	ldr	r3, [pc, #32]	; (80002e0 <LoopFillZerobss+0x24>)
 80002be:	429a      	cmp	r2, r3
 80002c0:	d3f9      	bcc.n	80002b6 <FillZerobss>
 80002c2:	f001 ff01 	bl	80020c8 <SystemInit>
 80002c6:	f000 f815 	bl	80002f4 <main>
 80002ca:	4770      	bx	lr
 80002cc:	20050000 	.word	0x20050000
 80002d0:	08002358 	.word	0x08002358
 80002d4:	20000000 	.word	0x20000000
 80002d8:	20000008 	.word	0x20000008
 80002dc:	20000008 	.word	0x20000008
 80002e0:	20004308 	.word	0x20004308

080002e4 <BusFault_Handler>:
 80002e4:	e7fe      	b.n	80002e4 <BusFault_Handler>
	...

080002e8 <uart_cb>:

  return 0;
}

static void uart_cb(void *arg, u8_t c) {
  print("got:%02x\n", c);
 80002e8:	4801      	ldr	r0, [pc, #4]	; (80002f0 <uart_cb+0x8>)
 80002ea:	f000 bbc7 	b.w	8000a7c <print>
 80002ee:	bf00      	nop
 80002f0:	08002114 	.word	0x08002114

080002f4 <main>:

  NVIC_EnableIRQ(USART3_IRQn);
  //NVIC_EnableIRQ(USART6_IRQn);
}

int main(void) {
 80002f4:	b580      	push	{r7, lr}
 80002f6:	b094      	sub	sp, #80	; 0x50
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80002f8:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 80002fc:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if (__ICACHE_PRESENT == 1)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     // invalidate I-Cache
 8000300:	4b7e      	ldr	r3, [pc, #504]	; (80004fc <main+0x208>)
 8000302:	2100      	movs	r1, #0
 8000304:	f8c3 1250 	str.w	r1, [r3, #592]	; 0x250
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  // enable I-Cache
 8000308:	695a      	ldr	r2, [r3, #20]
 800030a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800030e:	615a      	str	r2, [r3, #20]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000310:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 8000314:	f3bf 8f6f 	isb	sy
{
  #if (__DCACHE_PRESENT == 1)
    uint32_t ccsidr, sshift, wshift, sw;
    uint32_t sets, ways;

    SCB->CSSELR = (0UL << 1) | 0UL;         // Level 1 data cache
 8000318:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
    ccsidr  = SCB->CCSIDR;
 800031c:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
    sets    = (uint32_t)(CCSIDR_SETS(ccsidr));
 8000320:	f3c2 314e 	ubfx	r1, r2, #13, #15
    sshift  = (uint32_t)(CCSIDR_LSSHIFT(ccsidr) + 4UL);
 8000324:	f002 0507 	and.w	r5, r2, #7
    ways    = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000328:	f3c2 02c9 	ubfx	r2, r2, #3, #10
    wshift  = (uint32_t)((uint32_t)__CLZ(ways) & 0x1FUL);
 800032c:	fab2 f682 	clz	r6, r2
    uint32_t sets, ways;

    SCB->CSSELR = (0UL << 1) | 0UL;         // Level 1 data cache
    ccsidr  = SCB->CCSIDR;
    sets    = (uint32_t)(CCSIDR_SETS(ccsidr));
    sshift  = (uint32_t)(CCSIDR_LSSHIFT(ccsidr) + 4UL);
 8000330:	3504      	adds	r5, #4
    ways    = (uint32_t)(CCSIDR_WAYS(ccsidr));
    wshift  = (uint32_t)((uint32_t)__CLZ(ways) & 0x1FUL);
 8000332:	f006 061f 	and.w	r6, r6, #31
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000336:	f3bf 8f4f 	dsb	sy
    __DSB();

    do {                                   // invalidate D-Cache
         uint32_t tmpways = ways;
         do {
              sw = ((tmpways << wshift) | (sets << sshift));
 800033a:	fa01 fe05 	lsl.w	lr, r1, r5
    wshift  = (uint32_t)((uint32_t)__CLZ(ways) & 0x1FUL);

    __DSB();

    do {                                   // invalidate D-Cache
         uint32_t tmpways = ways;
 800033e:	4610      	mov	r0, r2
         do {
              sw = ((tmpways << wshift) | (sets << sshift));
 8000340:	fa00 f706 	lsl.w	r7, r0, r6
 8000344:	ea47 070e 	orr.w	r7, r7, lr
              SCB->DCISW = sw;
            } while(tmpways--);
 8000348:	f110 30ff 	adds.w	r0, r0, #4294967295	; 0xffffffff

    do {                                   // invalidate D-Cache
         uint32_t tmpways = ways;
         do {
              sw = ((tmpways << wshift) | (sets << sshift));
              SCB->DCISW = sw;
 800034c:	4c6b      	ldr	r4, [pc, #428]	; (80004fc <main+0x208>)
 800034e:	f8c3 7260 	str.w	r7, [r3, #608]	; 0x260
            } while(tmpways--);
 8000352:	d2f5      	bcs.n	8000340 <main+0x4c>
        } while(sets--);
 8000354:	f111 31ff 	adds.w	r1, r1, #4294967295	; 0xffffffff
 8000358:	d2ef      	bcs.n	800033a <main+0x46>
 800035a:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;   // enable D-Cache
 800035e:	6963      	ldr	r3, [r4, #20]
 8000360:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000364:	6163      	str	r3, [r4, #20]
 8000366:	f3bf 8f4f 	dsb	sy
    so that all instructions following the ISB are fetched from cache or
    memory, after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 800036a:	f3bf 8f6f 	isb	sy
  * @retval None
  */
__STATIC_INLINE void HAL_MPU_Disable(void)
{
  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 800036e:	6a63      	ldr	r3, [r4, #36]	; 0x24
  
  /* Disable the MPU */
  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
 8000370:	4e63      	ldr	r6, [pc, #396]	; (8000500 <main+0x20c>)
  * @retval None
  */
__STATIC_INLINE void HAL_MPU_Disable(void)
{
  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8000372:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000376:	6263      	str	r3, [r4, #36]	; 0x24
  
  /* Disable the MPU */
  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
 8000378:	6873      	ldr	r3, [r6, #4]
 800037a:	f023 0301 	bic.w	r3, r3, #1
 800037e:	6073      	str	r3, [r6, #4]
  /* Disable the MPU */
  HAL_MPU_Disable();

  /* Configure the MPU attributes as WT for SRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.BaseAddress = 0x20010000;
 8000380:	4b60      	ldr	r3, [pc, #384]	; (8000504 <main+0x210>)
 8000382:	9309      	str	r3, [sp, #36]	; 0x24
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 8000384:	2311      	movs	r3, #17
 8000386:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 800038a:	2303      	movs	r3, #3

  /* Disable the MPU */
  HAL_MPU_Disable();

  /* Configure the MPU attributes as WT for SRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 800038c:	2501      	movs	r5, #1
  MPU_InitStruct.BaseAddress = 0x20010000;
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 800038e:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.SubRegionDisable = 0x00;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8000392:	a808      	add	r0, sp, #32
  /* Configure the MPU attributes as WT for SRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.BaseAddress = 0x20010000;
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 8000394:	2300      	movs	r3, #0
 8000396:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
  MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 800039a:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
 800039e:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 80003a2:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
  MPU_InitStruct.SubRegionDisable = 0x00;
 80003a6:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 80003aa:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c

  /* Disable the MPU */
  HAL_MPU_Disable();

  /* Configure the MPU attributes as WT for SRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 80003ae:	f88d 5020 	strb.w	r5, [sp, #32]
  MPU_InitStruct.BaseAddress = 0x20010000;
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
  MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
 80003b2:	f88d 502e 	strb.w	r5, [sp, #46]	; 0x2e
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.SubRegionDisable = 0x00;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 80003b6:	f001 fa07 	bl	80017c8 <HAL_MPU_ConfigRegion>
  * @retval None
  */
__STATIC_INLINE void HAL_MPU_Enable(uint32_t MPU_Control)
{
  /* Enable the MPU */
  MPU->CTRL   = MPU_Control | MPU_CTRL_ENABLE_Msk;
 80003ba:	2305      	movs	r3, #5
 80003bc:	6073      	str	r3, [r6, #4]
  
  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 80003be:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80003c0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80003c4:	6263      	str	r3, [r4, #36]	; 0x24
  SCB_EnableICache();
  SCB_EnableDCache();

  MPU_Config();

  HAL_Init();
 80003c6:	f000 ff65 	bl	8001294 <HAL_Init>
  RCC_OscInitTypeDef RCC_OscInitStruct;
  HAL_StatusTypeDef ret = HAL_OK;

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80003ca:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80003ce:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  RCC_OscInitTypeDef RCC_OscInitStruct;
  HAL_StatusTypeDef ret = HAL_OK;

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80003d2:	9309      	str	r3, [sp, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80003d4:	920f      	str	r2, [sp, #60]	; 0x3c
  HAL_StatusTypeDef ret = HAL_OK;

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80003d6:	2302      	movs	r3, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
 80003d8:	2208      	movs	r2, #8
  HAL_StatusTypeDef ret = HAL_OK;

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80003da:	930e      	str	r3, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
 80003dc:	9210      	str	r2, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLN = 432;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80003de:	9312      	str	r3, [sp, #72]	; 0x48
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 432;
 80003e0:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 9;
 80003e4:	2309      	movs	r3, #9

  ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 80003e6:	a808      	add	r0, sp, #32
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  HAL_StatusTypeDef ret = HAL_OK;

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80003e8:	9508      	str	r5, [sp, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 432;
 80003ea:	9211      	str	r2, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 9;
 80003ec:	9313      	str	r3, [sp, #76]	; 0x4c

  ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 80003ee:	f001 fb33 	bl	8001a58 <HAL_RCC_OscConfig>
  if(ret != HAL_OK)
 80003f2:	b110      	cbz	r0, 80003fa <main+0x106>
  {
    halt("RCC osc config");
 80003f4:	4844      	ldr	r0, [pc, #272]	; (8000508 <main+0x214>)
 80003f6:	f000 f99d 	bl	8000734 <halt>
  }

  /* Activate the OverDrive to reach the 216 MHz Frequency */
  ret = HAL_PWREx_EnableOverDrive();
 80003fa:	f001 faf5 	bl	80019e8 <HAL_PWREx_EnableOverDrive>
  if(ret != HAL_OK)
 80003fe:	b110      	cbz	r0, 8000406 <main+0x112>
  {
    halt("overdrive");
 8000400:	4842      	ldr	r0, [pc, #264]	; (800050c <main+0x218>)
 8000402:	f000 f997 	bl	8000734 <halt>
  }

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 8000406:	230f      	movs	r3, #15
 8000408:	9303      	str	r3, [sp, #12]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800040a:	2302      	movs	r3, #2
 800040c:	9304      	str	r3, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800040e:	2300      	movs	r3, #0
 8000410:	9305      	str	r3, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8000412:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8000416:	9306      	str	r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
 8000418:	2107      	movs	r1, #7
  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 800041a:	f44f 5380 	mov.w	r3, #4096	; 0x1000

  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
 800041e:	a803      	add	r0, sp, #12
  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8000420:	9307      	str	r3, [sp, #28]

  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
 8000422:	f001 fcef 	bl	8001e04 <HAL_RCC_ClockConfig>
  if(ret != HAL_OK)
 8000426:	b110      	cbz	r0, 800042e <main+0x13a>
  {
    halt("clockconfig");
 8000428:	4839      	ldr	r0, [pc, #228]	; (8000510 <main+0x21c>)
 800042a:	f000 f983 	bl	8000734 <halt>

static void init_uart(void) {
  GPIO_InitTypeDef gpio_init_structure;

  // UART
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800042e:	4b39      	ldr	r3, [pc, #228]	; (8000514 <main+0x220>)
  gpio_init_structure.Pin = GPIO_PIN_8; // tx
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
  gpio_init_structure.Pull = GPIO_PULLUP;
  gpio_init_structure.Speed = GPIO_SPEED_FAST;
  gpio_init_structure.Alternate = GPIO_AF7_USART3;
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 8000430:	4839      	ldr	r0, [pc, #228]	; (8000518 <main+0x224>)

static void init_uart(void) {
  GPIO_InitTypeDef gpio_init_structure;

  // UART
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000432:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000434:	f042 0208 	orr.w	r2, r2, #8
 8000438:	631a      	str	r2, [r3, #48]	; 0x30
 800043a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800043c:	f002 0208 	and.w	r2, r2, #8
 8000440:	9202      	str	r2, [sp, #8]
 8000442:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_USART3_CLK_ENABLE();
 8000444:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000446:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800044a:	641a      	str	r2, [r3, #64]	; 0x40
 800044c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800044e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8000452:	9303      	str	r3, [sp, #12]

  gpio_init_structure.Pin = GPIO_PIN_8; // tx
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 8000454:	2402      	movs	r4, #2
  gpio_init_structure.Pull = GPIO_PULLUP;
 8000456:	2501      	movs	r5, #1
  gpio_init_structure.Speed = GPIO_SPEED_FAST;
  gpio_init_structure.Alternate = GPIO_AF7_USART3;
 8000458:	2607      	movs	r6, #7
static void init_uart(void) {
  GPIO_InitTypeDef gpio_init_structure;

  // UART
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_USART3_CLK_ENABLE();
 800045a:	9b03      	ldr	r3, [sp, #12]

  gpio_init_structure.Pin = GPIO_PIN_8; // tx
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 800045c:	9409      	str	r4, [sp, #36]	; 0x24

  // UART
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_USART3_CLK_ENABLE();

  gpio_init_structure.Pin = GPIO_PIN_8; // tx
 800045e:	f44f 7380 	mov.w	r3, #256	; 0x100
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
  gpio_init_structure.Pull = GPIO_PULLUP;
  gpio_init_structure.Speed = GPIO_SPEED_FAST;
  gpio_init_structure.Alternate = GPIO_AF7_USART3;
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 8000462:	a908      	add	r1, sp, #32

  // UART
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_USART3_CLK_ENABLE();

  gpio_init_structure.Pin = GPIO_PIN_8; // tx
 8000464:	9308      	str	r3, [sp, #32]
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
  gpio_init_structure.Pull = GPIO_PULLUP;
 8000466:	950a      	str	r5, [sp, #40]	; 0x28
  gpio_init_structure.Speed = GPIO_SPEED_FAST;
 8000468:	940b      	str	r4, [sp, #44]	; 0x2c
  gpio_init_structure.Alternate = GPIO_AF7_USART3;
 800046a:	960c      	str	r6, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 800046c:	f001 f9d2 	bl	8001814 <HAL_GPIO_Init>

  gpio_init_structure.Pin = GPIO_PIN_9; // rx
 8000470:	f44f 7300 	mov.w	r3, #512	; 0x200
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
  gpio_init_structure.Pull = GPIO_PULLUP;
  gpio_init_structure.Speed = GPIO_SPEED_FAST;
  gpio_init_structure.Alternate = GPIO_AF7_USART3;
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 8000474:	a908      	add	r1, sp, #32
 8000476:	4828      	ldr	r0, [pc, #160]	; (8000518 <main+0x224>)
  gpio_init_structure.Pull = GPIO_PULLUP;
  gpio_init_structure.Speed = GPIO_SPEED_FAST;
  gpio_init_structure.Alternate = GPIO_AF7_USART3;
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);

  gpio_init_structure.Pin = GPIO_PIN_9; // rx
 8000478:	9308      	str	r3, [sp, #32]
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 800047a:	9409      	str	r4, [sp, #36]	; 0x24
  gpio_init_structure.Pull = GPIO_PULLUP;
 800047c:	950a      	str	r5, [sp, #40]	; 0x28
  gpio_init_structure.Speed = GPIO_SPEED_FAST;
 800047e:	940b      	str	r4, [sp, #44]	; 0x2c
  gpio_init_structure.Alternate = GPIO_AF7_USART3;
 8000480:	960c      	str	r6, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 8000482:	f001 f9c7 	bl	8001814 <HAL_GPIO_Init>

  UART_init();
 8000486:	f000 fdad 	bl	8000fe4 <UART_init>
  UART_assure_tx(_UART(IOSTD), TRUE);
 800048a:	4629      	mov	r1, r5
 800048c:	4823      	ldr	r0, [pc, #140]	; (800051c <main+0x228>)
 800048e:	f000 fc55 	bl	8000d3c <UART_assure_tx>
  UART_set_callback(_UART(IOSTD), uart_cb, NULL);
 8000492:	4923      	ldr	r1, [pc, #140]	; (8000520 <main+0x22c>)
 8000494:	4821      	ldr	r0, [pc, #132]	; (800051c <main+0x228>)
 8000496:	2200      	movs	r2, #0
 8000498:	f000 fc4b 	bl	8000d32 <UART_set_callback>

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800049c:	4b21      	ldr	r3, [pc, #132]	; (8000524 <main+0x230>)
SDRAM_HandleTypeDef      hsdram;
FMC_SDRAM_TimingTypeDef  SDRAM_Timing;
FMC_SDRAM_CommandTypeDef command;

static void print_hello() {
  print("\nProcessor running...\n\n");
 800049e:	4822      	ldr	r0, [pc, #136]	; (8000528 <main+0x234>)
 80004a0:	2280      	movs	r2, #128	; 0x80
 80004a2:	605a      	str	r2, [r3, #4]
 80004a4:	f000 faea 	bl	8000a7c <print>
  print("FLASH: 0x%08x -- 0x%08x (%ikB)\n",
      (u32_t)&FLASH_START, (u32_t)&FLASH_START+(u32_t)&FLASH_SIZE, (u32_t)&FLASH_SIZE/1024);
 80004a8:	4920      	ldr	r1, [pc, #128]	; (800052c <main+0x238>)
 80004aa:	4a21      	ldr	r2, [pc, #132]	; (8000530 <main+0x23c>)
FMC_SDRAM_TimingTypeDef  SDRAM_Timing;
FMC_SDRAM_CommandTypeDef command;

static void print_hello() {
  print("\nProcessor running...\n\n");
  print("FLASH: 0x%08x -- 0x%08x (%ikB)\n",
 80004ac:	4821      	ldr	r0, [pc, #132]	; (8000534 <main+0x240>)
 80004ae:	0a93      	lsrs	r3, r2, #10
 80004b0:	440a      	add	r2, r1
 80004b2:	f000 fae3 	bl	8000a7c <print>
      (u32_t)&FLASH_START, (u32_t)&FLASH_START+(u32_t)&FLASH_SIZE, (u32_t)&FLASH_SIZE/1024);
  print("RAM:   0x%08x -- 0x%08x (%ikB)\n",
      (u32_t)&RAM_START, (u32_t)&RAM_START+(u32_t)&RAM_SIZE, (u32_t)&RAM_SIZE/1024);
 80004b6:	4920      	ldr	r1, [pc, #128]	; (8000538 <main+0x244>)
 80004b8:	4a20      	ldr	r2, [pc, #128]	; (800053c <main+0x248>)

static void print_hello() {
  print("\nProcessor running...\n\n");
  print("FLASH: 0x%08x -- 0x%08x (%ikB)\n",
      (u32_t)&FLASH_START, (u32_t)&FLASH_START+(u32_t)&FLASH_SIZE, (u32_t)&FLASH_SIZE/1024);
  print("RAM:   0x%08x -- 0x%08x (%ikB)\n",
 80004ba:	4821      	ldr	r0, [pc, #132]	; (8000540 <main+0x24c>)
 80004bc:	0a93      	lsrs	r3, r2, #10
 80004be:	440a      	add	r2, r1
 80004c0:	f000 fadc 	bl	8000a7c <print>
      (u32_t)&RAM_START, (u32_t)&RAM_START+(u32_t)&RAM_SIZE, (u32_t)&RAM_SIZE/1024);
  print("\nProcessor clock speeds\n"
 80004c4:	f001 fdba 	bl	800203c <HAL_RCC_GetHCLKFreq>
 80004c8:	4604      	mov	r4, r0
 80004ca:	f001 fdd1 	bl	8002070 <HAL_RCC_GetPCLK1Freq>
 80004ce:	4605      	mov	r5, r0
 80004d0:	f001 fde4 	bl	800209c <HAL_RCC_GetPCLK2Freq>
 80004d4:	4606      	mov	r6, r0
 80004d6:	f001 fd73 	bl	8001fc0 <HAL_RCC_GetSysClockFreq>
 80004da:	4633      	mov	r3, r6
 80004dc:	462a      	mov	r2, r5
 80004de:	4621      	mov	r1, r4
 80004e0:	9000      	str	r0, [sp, #0]
 80004e2:	4818      	ldr	r0, [pc, #96]	; (8000544 <main+0x250>)
 80004e4:	f000 faca 	bl	8000a7c <print>

  init_uart();

  print_hello();

  print("\n\napp start\n\n");
 80004e8:	4817      	ldr	r0, [pc, #92]	; (8000548 <main+0x254>)
 80004ea:	f000 fac7 	bl	8000a7c <print>

  app_start();
 80004ee:	f000 f831 	bl	8000554 <app_start>

  print("\nstartup finished\n");
 80004f2:	4816      	ldr	r0, [pc, #88]	; (800054c <main+0x258>)
 80004f4:	f000 fac2 	bl	8000a7c <print>
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 80004f8:	bf30      	wfi
 80004fa:	e7fd      	b.n	80004f8 <main+0x204>
 80004fc:	e000ed00 	.word	0xe000ed00
 8000500:	e000ed90 	.word	0xe000ed90
 8000504:	20010000 	.word	0x20010000
 8000508:	0800211e 	.word	0x0800211e
 800050c:	0800212d 	.word	0x0800212d
 8000510:	08002137 	.word	0x08002137
 8000514:	40023800 	.word	0x40023800
 8000518:	40020c00 	.word	0x40020c00
 800051c:	20003eec 	.word	0x20003eec
 8000520:	080002e9 	.word	0x080002e9
 8000524:	e000e100 	.word	0xe000e100
 8000528:	08002143 	.word	0x08002143
 800052c:	08000000 	.word	0x08000000
 8000530:	00100000 	.word	0x00100000
 8000534:	0800215b 	.word	0x0800215b
 8000538:	20000000 	.word	0x20000000
 800053c:	00050000 	.word	0x00050000
 8000540:	0800217b 	.word	0x0800217b
 8000544:	0800219b 	.word	0x0800219b
 8000548:	080021f7 	.word	0x080021f7
 800054c:	08002205 	.word	0x08002205

08000550 <SysTick_Handler>:
  HAL_MPU_ConfigRegion(&MPU_InitStruct);

  /* Enable the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
}
void SysTick_Handler(void) { HAL_IncTick(); }
 8000550:	f000 beb2 	b.w	80012b8 <HAL_IncTick>

08000554 <app_start>:
static void yin_init(void) {
  Yin_init(&yin, YIN_BUF_SIZE, 0.15, _work);
}


void app_start(void) {
 8000554:	b5f0      	push	{r4, r5, r6, r7, lr}
  print("adc init..\n");
 8000556:	4831      	ldr	r0, [pc, #196]	; (800061c <app_start+0xc8>)
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(ADCx_CHANNEL_GPIO_PORT, &GPIO_InitStruct);

  /*##-1- Configure the ADC peripheral #######################################*/
  adc_hdl.Instance          = ADCx;
 8000558:	4c31      	ldr	r4, [pc, #196]	; (8000620 <app_start+0xcc>)
static void yin_init(void) {
  Yin_init(&yin, YIN_BUF_SIZE, 0.15, _work);
}


void app_start(void) {
 800055a:	b08d      	sub	sp, #52	; 0x34
  print("adc init..\n");
 800055c:	f000 fa8e 	bl	8000a7c <print>
#define YIN_BUF_SIZE    SPL_FREQ

static void adc_init() {
  GPIO_InitTypeDef          GPIO_InitStruct;

  ADCx_CLK_ENABLE();
 8000560:	4b30      	ldr	r3, [pc, #192]	; (8000624 <app_start+0xd0>)
  ADCx_CHANNEL_GPIO_CLK_ENABLE();

  GPIO_InitStruct.Pin = ADCx_CHANNEL_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(ADCx_CHANNEL_GPIO_PORT, &GPIO_InitStruct);
 8000562:	4831      	ldr	r0, [pc, #196]	; (8000628 <app_start+0xd4>)
#define YIN_BUF_SIZE    SPL_FREQ

static void adc_init() {
  GPIO_InitTypeDef          GPIO_InitStruct;

  ADCx_CLK_ENABLE();
 8000564:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000566:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800056a:	645a      	str	r2, [r3, #68]	; 0x44
 800056c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800056e:	f402 6280 	and.w	r2, r2, #1024	; 0x400
 8000572:	9201      	str	r2, [sp, #4]
 8000574:	9a01      	ldr	r2, [sp, #4]
  ADCx_CHANNEL_GPIO_CLK_ENABLE();
 8000576:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000578:	f042 0220 	orr.w	r2, r2, #32
 800057c:	631a      	str	r2, [r3, #48]	; 0x30
 800057e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000580:	f003 0320 	and.w	r3, r3, #32
 8000584:	9302      	str	r3, [sp, #8]

  GPIO_InitStruct.Pin = ADCx_CHANNEL_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000586:	2500      	movs	r5, #0

static void adc_init() {
  GPIO_InitTypeDef          GPIO_InitStruct;

  ADCx_CLK_ENABLE();
  ADCx_CHANNEL_GPIO_CLK_ENABLE();
 8000588:	9b02      	ldr	r3, [sp, #8]

  GPIO_InitStruct.Pin = ADCx_CHANNEL_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800058a:	9509      	str	r5, [sp, #36]	; 0x24
  GPIO_InitTypeDef          GPIO_InitStruct;

  ADCx_CLK_ENABLE();
  ADCx_CHANNEL_GPIO_CLK_ENABLE();

  GPIO_InitStruct.Pin = ADCx_CHANNEL_PIN;
 800058c:	2310      	movs	r3, #16
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800058e:	2703      	movs	r7, #3
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(ADCx_CHANNEL_GPIO_PORT, &GPIO_InitStruct);
 8000590:	a907      	add	r1, sp, #28
  GPIO_InitTypeDef          GPIO_InitStruct;

  ADCx_CLK_ENABLE();
  ADCx_CHANNEL_GPIO_CLK_ENABLE();

  GPIO_InitStruct.Pin = ADCx_CHANNEL_PIN;
 8000592:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8000594:	9708      	str	r7, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(ADCx_CHANNEL_GPIO_PORT, &GPIO_InitStruct);
 8000596:	f001 f93d 	bl	8001814 <HAL_GPIO_Init>

  /*##-1- Configure the ADC peripheral #######################################*/
  adc_hdl.Instance          = ADCx;
  adc_hdl.Init.ClockPrescaler        = ADC_CLOCKPRESCALER_PCLK_DIV8;
 800059a:	4a24      	ldr	r2, [pc, #144]	; (800062c <app_start+0xd8>)
  adc_hdl.Init.Resolution            = ADC_RESOLUTION_12B;
 800059c:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(ADCx_CHANNEL_GPIO_PORT, &GPIO_InitStruct);

  /*##-1- Configure the ADC peripheral #######################################*/
  adc_hdl.Instance          = ADCx;
  adc_hdl.Init.ClockPrescaler        = ADC_CLOCKPRESCALER_PCLK_DIV8;
 800059e:	f44f 3340 	mov.w	r3, #196608	; 0x30000
  adc_hdl.Init.Resolution            = ADC_RESOLUTION_12B;
  adc_hdl.Init.DataAlign             = ADC_DATAALIGN_RIGHT;
  adc_hdl.Init.ScanConvMode          = DISABLE;                       /* Sequencer disabled (ADC conversion on only 1 channel: channel set on rank 1) */
  adc_hdl.Init.EOCSelection          = DISABLE;
  adc_hdl.Init.ContinuousConvMode    = ENABLE;                        /* Continuous mode disabled to have only 1 conversion at each conversion trig */
 80005a2:	2601      	movs	r6, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(ADCx_CHANNEL_GPIO_PORT, &GPIO_InitStruct);

  /*##-1- Configure the ADC peripheral #######################################*/
  adc_hdl.Instance          = ADCx;
  adc_hdl.Init.ClockPrescaler        = ADC_CLOCKPRESCALER_PCLK_DIV8;
 80005a4:	e884 000c 	stmia.w	r4, {r2, r3}
  adc_hdl.Init.DiscontinuousConvMode = DISABLE;                       /* Parameter discarded because sequencer is disabled */
  adc_hdl.Init.NbrOfDiscConversion   = 0;
  adc_hdl.Init.ExternalTrigConv      = ADC_SOFTWARE_START;
  adc_hdl.Init.ExternalTrigConvEdge  = ADC_EXTERNALTRIGCONVEDGE_NONE;

  if (HAL_ADC_Init(&adc_hdl) != HAL_OK)
 80005a8:	4620      	mov	r0, r4
  adc_hdl.Init.ContinuousConvMode    = ENABLE;                        /* Continuous mode disabled to have only 1 conversion at each conversion trig */
  adc_hdl.Init.DMAContinuousRequests = ENABLE;
  adc_hdl.Init.NbrOfConversion       = 1;
  adc_hdl.Init.DiscontinuousConvMode = DISABLE;                       /* Parameter discarded because sequencer is disabled */
  adc_hdl.Init.NbrOfDiscConversion   = 0;
  adc_hdl.Init.ExternalTrigConv      = ADC_SOFTWARE_START;
 80005aa:	4b21      	ldr	r3, [pc, #132]	; (8000630 <app_start+0xdc>)

  /*##-1- Configure the ADC peripheral #######################################*/
  adc_hdl.Instance          = ADCx;
  adc_hdl.Init.ClockPrescaler        = ADC_CLOCKPRESCALER_PCLK_DIV8;
  adc_hdl.Init.Resolution            = ADC_RESOLUTION_12B;
  adc_hdl.Init.DataAlign             = ADC_DATAALIGN_RIGHT;
 80005ac:	60e5      	str	r5, [r4, #12]
  adc_hdl.Init.ScanConvMode          = DISABLE;                       /* Sequencer disabled (ADC conversion on only 1 channel: channel set on rank 1) */
 80005ae:	6125      	str	r5, [r4, #16]
  adc_hdl.Init.EOCSelection          = DISABLE;
 80005b0:	6165      	str	r5, [r4, #20]
  adc_hdl.Init.ContinuousConvMode    = ENABLE;                        /* Continuous mode disabled to have only 1 conversion at each conversion trig */
 80005b2:	61a6      	str	r6, [r4, #24]
  adc_hdl.Init.DMAContinuousRequests = ENABLE;
 80005b4:	61e6      	str	r6, [r4, #28]
  adc_hdl.Init.NbrOfConversion       = 1;
 80005b6:	6226      	str	r6, [r4, #32]
  adc_hdl.Init.DiscontinuousConvMode = DISABLE;                       /* Parameter discarded because sequencer is disabled */
 80005b8:	6265      	str	r5, [r4, #36]	; 0x24
  adc_hdl.Init.NbrOfDiscConversion   = 0;
 80005ba:	62a5      	str	r5, [r4, #40]	; 0x28
  adc_hdl.Init.ExternalTrigConv      = ADC_SOFTWARE_START;
 80005bc:	62e3      	str	r3, [r4, #44]	; 0x2c
  adc_hdl.Init.ExternalTrigConvEdge  = ADC_EXTERNALTRIGCONVEDGE_NONE;
 80005be:	6325      	str	r5, [r4, #48]	; 0x30

  if (HAL_ADC_Init(&adc_hdl) != HAL_OK)
 80005c0:	f000 fe8a 	bl	80012d8 <HAL_ADC_Init>
 80005c4:	b118      	cbz	r0, 80005ce <app_start+0x7a>
  {
    /* ADC initialization Error */
    ASSERT(FALSE, "adc init err\n");
 80005c6:	481b      	ldr	r0, [pc, #108]	; (8000634 <app_start+0xe0>)
 80005c8:	f000 fa58 	bl	8000a7c <print>
 80005cc:	e7fe      	b.n	80005cc <app_start+0x78>
  }

  /*##-2- Configure ADC regular channel ######################################*/
  ADC_ChannelConfTypeDef sConfig;

  sConfig.Channel      = ADCx_CHANNEL;
 80005ce:	230e      	movs	r3, #14
 80005d0:	9303      	str	r3, [sp, #12]
  sConfig.Rank         = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_144CYCLES; //480CYCLES;//ADC_SAMPLETIME_3CYCLES;
  sConfig.Offset       = 0;
 80005d2:	9006      	str	r0, [sp, #24]
  /*##-2- Configure ADC regular channel ######################################*/
  ADC_ChannelConfTypeDef sConfig;

  sConfig.Channel      = ADCx_CHANNEL;
  sConfig.Rank         = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_144CYCLES; //480CYCLES;//ADC_SAMPLETIME_3CYCLES;
 80005d4:	2306      	movs	r3, #6
  sConfig.Offset       = 0;

  if (HAL_ADC_ConfigChannel(&adc_hdl, &sConfig) != HAL_OK)
 80005d6:	a903      	add	r1, sp, #12
 80005d8:	4620      	mov	r0, r4

  /*##-2- Configure ADC regular channel ######################################*/
  ADC_ChannelConfTypeDef sConfig;

  sConfig.Channel      = ADCx_CHANNEL;
  sConfig.Rank         = 1;
 80005da:	9604      	str	r6, [sp, #16]
  sConfig.SamplingTime = ADC_SAMPLETIME_144CYCLES; //480CYCLES;//ADC_SAMPLETIME_3CYCLES;
 80005dc:	9305      	str	r3, [sp, #20]
  sConfig.Offset       = 0;

  if (HAL_ADC_ConfigChannel(&adc_hdl, &sConfig) != HAL_OK)
 80005de:	f000 fff3 	bl	80015c8 <HAL_ADC_ConfigChannel>
 80005e2:	4602      	mov	r2, r0
 80005e4:	b118      	cbz	r0, 80005ee <app_start+0x9a>
  {
    /* Channel Configuration Error */
    ASSERT(FALSE, "adc channel conf err\n");
 80005e6:	4814      	ldr	r0, [pc, #80]	; (8000638 <app_start+0xe4>)
 80005e8:	f000 fa48 	bl	8000a7c <print>
 80005ec:	e7fe      	b.n	80005ec <app_start+0x98>
  }

  HAL_NVIC_SetPriority(ADC_IRQn, 3,0);
 80005ee:	4639      	mov	r1, r7
 80005f0:	2012      	movs	r0, #18
 80005f2:	f001 f893 	bl	800171c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(ADC_IRQn);
 80005f6:	2012      	movs	r0, #18
 80005f8:	f001 f8c4 	bl	8001784 <HAL_NVIC_EnableIRQ>


void app_start(void) {
  print("adc init..\n");
  adc_init();
  print("adc init.. OK\n");
 80005fc:	480f      	ldr	r0, [pc, #60]	; (800063c <app_start+0xe8>)
 80005fe:	f000 fa3d 	bl	8000a7c <print>
  HAL_NVIC_EnableIRQ(ADC_IRQn);
}

static float _work[YIN_BUF_SIZE/2];
static void yin_init(void) {
  Yin_init(&yin, YIN_BUF_SIZE, 0.15, _work);
 8000602:	4a0f      	ldr	r2, [pc, #60]	; (8000640 <app_start+0xec>)
 8000604:	ed9f 0a0f 	vldr	s0, [pc, #60]	; 8000644 <app_start+0xf0>
 8000608:	480f      	ldr	r0, [pc, #60]	; (8000648 <app_start+0xf4>)
 800060a:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
 800060e:	f000 fdfa 	bl	8001206 <Yin_init>
  adc_init();
  print("adc init.. OK\n");

  yin_init();

  HAL_ADC_Start_IT(&adc_hdl);
 8000612:	4620      	mov	r0, r4
 8000614:	f000 fefc 	bl	8001410 <HAL_ADC_Start_IT>
}
 8000618:	b00d      	add	sp, #52	; 0x34
 800061a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800061c:	08002218 	.word	0x08002218
 8000620:	20003e98 	.word	0x20003e98
 8000624:	40023800 	.word	0x40023800
 8000628:	40021400 	.word	0x40021400
 800062c:	40012200 	.word	0x40012200
 8000630:	0f000001 	.word	0x0f000001
 8000634:	08002224 	.word	0x08002224
 8000638:	08002232 	.word	0x08002232
 800063c:	08002248 	.word	0x08002248
 8000640:	20000010 	.word	0x20000010
 8000644:	3e19999a 	.word	0x3e19999a
 8000648:	20003edc 	.word	0x20003edc

0800064c <ADC_IRQHandler>:

void ADC_IRQHandler(void) {
  HAL_ADC_IRQHandler(&adc_hdl);
 800064c:	4801      	ldr	r0, [pc, #4]	; (8000654 <ADC_IRQHandler+0x8>)
 800064e:	f000 bf41 	b.w	80014d4 <HAL_ADC_IRQHandler>
 8000652:	bf00      	nop
 8000654:	20003e98 	.word	0x20003e98

08000658 <HAL_ADC_ErrorCallback>:
}

void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc) {
  ASSERT(FALSE, "adc error %08x\n", hadc->ErrorCode);
 8000658:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800065a:	4802      	ldr	r0, [pc, #8]	; (8000664 <HAL_ADC_ErrorCallback+0xc>)

void ADC_IRQHandler(void) {
  HAL_ADC_IRQHandler(&adc_hdl);
}

void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc) {
 800065c:	b508      	push	{r3, lr}
  ASSERT(FALSE, "adc error %08x\n", hadc->ErrorCode);
 800065e:	f000 fa0d 	bl	8000a7c <print>
 8000662:	e7fe      	b.n	8000662 <HAL_ADC_ErrorCallback+0xa>
 8000664:	08002257 	.word	0x08002257

08000668 <HAL_ADC_ConvCpltCallback>:
static int16_t min = 0;
static int16_t max = 0;
static int32_t sum = 0;
static int16_t data[YIN_BUF_SIZE];
uint32_t ix = 0;
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc) {
 8000668:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800066c:	ed2d 8b02 	vpush	{d8}
 8000670:	b084      	sub	sp, #16
  uint32_t raw = HAL_ADC_GetValue(hadc);
 8000672:	f000 ff2b 	bl	80014cc <HAL_ADC_GetValue>
  int16_t v = (int16_t)(raw-0x0800);
  data[ix] = v;
 8000676:	4e27      	ldr	r6, [pc, #156]	; (8000714 <HAL_ADC_ConvCpltCallback+0xac>)
  sum += v;
 8000678:	4d27      	ldr	r5, [pc, #156]	; (8000718 <HAL_ADC_ConvCpltCallback+0xb0>)
static int16_t data[YIN_BUF_SIZE];
uint32_t ix = 0;
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc) {
  uint32_t raw = HAL_ADC_GetValue(hadc);
  int16_t v = (int16_t)(raw-0x0800);
  data[ix] = v;
 800067a:	6833      	ldr	r3, [r6, #0]
 800067c:	4927      	ldr	r1, [pc, #156]	; (800071c <HAL_ADC_ConvCpltCallback+0xb4>)
  sum += v;
 800067e:	682a      	ldr	r2, [r5, #0]
  min = v < min ? v : min;
 8000680:	4f27      	ldr	r7, [pc, #156]	; (8000720 <HAL_ADC_ConvCpltCallback+0xb8>)
  max = v > max ? v : max;
 8000682:	4c28      	ldr	r4, [pc, #160]	; (8000724 <HAL_ADC_ConvCpltCallback+0xbc>)
static int32_t sum = 0;
static int16_t data[YIN_BUF_SIZE];
uint32_t ix = 0;
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc) {
  uint32_t raw = HAL_ADC_GetValue(hadc);
  int16_t v = (int16_t)(raw-0x0800);
 8000684:	f5a0 6000 	sub.w	r0, r0, #2048	; 0x800
 8000688:	b280      	uxth	r0, r0
  data[ix] = v;
 800068a:	f821 0013 	strh.w	r0, [r1, r3, lsl #1]
  sum += v;
 800068e:	b200      	sxth	r0, r0
 8000690:	4402      	add	r2, r0
 8000692:	602a      	str	r2, [r5, #0]
  min = v < min ? v : min;
 8000694:	f9b7 2000 	ldrsh.w	r2, [r7]
 8000698:	4282      	cmp	r2, r0
 800069a:	bfa8      	it	ge
 800069c:	4602      	movge	r2, r0
 800069e:	803a      	strh	r2, [r7, #0]
  max = v > max ? v : max;
 80006a0:	f9b4 2000 	ldrsh.w	r2, [r4]
  ix++;
 80006a4:	3301      	adds	r3, #1
  uint32_t raw = HAL_ADC_GetValue(hadc);
  int16_t v = (int16_t)(raw-0x0800);
  data[ix] = v;
  sum += v;
  min = v < min ? v : min;
  max = v > max ? v : max;
 80006a6:	4290      	cmp	r0, r2
 80006a8:	bfb8      	it	lt
 80006aa:	4610      	movlt	r0, r2
  ix++;
  if (ix >= YIN_BUF_SIZE) {
 80006ac:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
  uint32_t raw = HAL_ADC_GetValue(hadc);
  int16_t v = (int16_t)(raw-0x0800);
  data[ix] = v;
  sum += v;
  min = v < min ? v : min;
  max = v > max ? v : max;
 80006b0:	8020      	strh	r0, [r4, #0]
  ix++;
 80006b2:	6033      	str	r3, [r6, #0]
  if (ix >= YIN_BUF_SIZE) {
 80006b4:	d329      	bcc.n	800070a <HAL_ADC_ConvCpltCallback+0xa2>
    float freq = Yin_getPitch(&yin, data);
 80006b6:	481c      	ldr	r0, [pc, #112]	; (8000728 <HAL_ADC_ConvCpltCallback+0xc0>)
 80006b8:	f000 fdbc 	bl	8001234 <Yin_getPitch>
    print("sum:%6d    min:%4d    max:%4d    avg:%4d    freq:%d %d%%\n",
        sum, min, max, sum/YIN_BUF_SIZE, (int)freq, (int)(100*Yin_getProbability(&yin)));
 80006bc:	481a      	ldr	r0, [pc, #104]	; (8000728 <HAL_ADC_ConvCpltCallback+0xc0>)
  min = v < min ? v : min;
  max = v > max ? v : max;
  ix++;
  if (ix >= YIN_BUF_SIZE) {
    float freq = Yin_getPitch(&yin, data);
    print("sum:%6d    min:%4d    max:%4d    avg:%4d    freq:%d %d%%\n",
 80006be:	f8d5 8000 	ldr.w	r8, [r5]
 80006c2:	f9b7 9000 	ldrsh.w	r9, [r7]
 80006c6:	f9b4 a000 	ldrsh.w	sl, [r4]
  sum += v;
  min = v < min ? v : min;
  max = v > max ? v : max;
  ix++;
  if (ix >= YIN_BUF_SIZE) {
    float freq = Yin_getPitch(&yin, data);
 80006ca:	eeb0 8a40 	vmov.f32	s16, s0
    print("sum:%6d    min:%4d    max:%4d    avg:%4d    freq:%d %d%%\n",
        sum, min, max, sum/YIN_BUF_SIZE, (int)freq, (int)(100*Yin_getProbability(&yin)));
 80006ce:	f000 fdcb 	bl	8001268 <Yin_getProbability>
  min = v < min ? v : min;
  max = v > max ? v : max;
  ix++;
  if (ix >= YIN_BUF_SIZE) {
    float freq = Yin_getPitch(&yin, data);
    print("sum:%6d    min:%4d    max:%4d    avg:%4d    freq:%d %d%%\n",
 80006d2:	eddf 7a16 	vldr	s15, [pc, #88]	; 800072c <HAL_ADC_ConvCpltCallback+0xc4>
 80006d6:	ee20 0a27 	vmul.f32	s0, s0, s15
 80006da:	eebd 8ac8 	vcvt.s32.f32	s16, s16
 80006de:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 80006e2:	4653      	mov	r3, sl
 80006e4:	ed8d 0a02 	vstr	s0, [sp, #8]
 80006e8:	ed8d 8a01 	vstr	s16, [sp, #4]
 80006ec:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 80006f0:	464a      	mov	r2, r9
 80006f2:	fb98 f0f0 	sdiv	r0, r8, r0
 80006f6:	4641      	mov	r1, r8
 80006f8:	9000      	str	r0, [sp, #0]
 80006fa:	480d      	ldr	r0, [pc, #52]	; (8000730 <HAL_ADC_ConvCpltCallback+0xc8>)
 80006fc:	f000 f9be 	bl	8000a7c <print>
        sum, min, max, sum/YIN_BUF_SIZE, (int)freq, (int)(100*Yin_getProbability(&yin)));
    max = min = ix = sum = 0;
 8000700:	2300      	movs	r3, #0
 8000702:	602b      	str	r3, [r5, #0]
 8000704:	6033      	str	r3, [r6, #0]
 8000706:	803b      	strh	r3, [r7, #0]
 8000708:	8023      	strh	r3, [r4, #0]
  }
}
 800070a:	b004      	add	sp, #16
 800070c:	ecbd 8b02 	vpop	{d8}
 8000710:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000714:	20003e90 	.word	0x20003e90
 8000718:	2000000c 	.word	0x2000000c
 800071c:	20001f50 	.word	0x20001f50
 8000720:	20000008 	.word	0x20000008
 8000724:	2000000a 	.word	0x2000000a
 8000728:	20003edc 	.word	0x20003edc
 800072c:	42c80000 	.word	0x42c80000
 8000730:	08002267 	.word	0x08002267

08000734 <halt>:
#include <uart_driver.h>
#include <miniutils.h>
#include "stm32f7xx_hal.h"
#include <stdarg.h>

void halt(const char *str, ...) {
 8000734:	b40f      	push	{r0, r1, r2, r3}
 8000736:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8000738:	ac06      	add	r4, sp, #24
  UART_tx_flush(_UART(IOSTD));
 800073a:	480a      	ldr	r0, [pc, #40]	; (8000764 <halt+0x30>)
#include <uart_driver.h>
#include <miniutils.h>
#include "stm32f7xx_hal.h"
#include <stdarg.h>

void halt(const char *str, ...) {
 800073c:	f854 5b04 	ldr.w	r5, [r4], #4
  UART_tx_flush(_UART(IOSTD));
 8000740:	f000 fa35 	bl	8000bae <UART_tx_flush>
  UART_sync_tx(_UART(IOSTD), TRUE);
 8000744:	2101      	movs	r1, #1
 8000746:	4807      	ldr	r0, [pc, #28]	; (8000764 <halt+0x30>)
 8000748:	f000 fafe 	bl	8000d48 <UART_sync_tx>

  print("\n**** HALT ****\n");
 800074c:	4806      	ldr	r0, [pc, #24]	; (8000768 <halt+0x34>)
 800074e:	f000 f995 	bl	8000a7c <print>
  va_list arg_p;
  va_start(arg_p, str);
  vprint(str, arg_p);
 8000752:	4628      	mov	r0, r5
 8000754:	4621      	mov	r1, r4
  UART_tx_flush(_UART(IOSTD));
  UART_sync_tx(_UART(IOSTD), TRUE);

  print("\n**** HALT ****\n");
  va_list arg_p;
  va_start(arg_p, str);
 8000756:	9401      	str	r4, [sp, #4]
  vprint(str, arg_p);
 8000758:	f000 f99e 	bl	8000a98 <vprint>
  va_end(arg_p);
  print("\n");
 800075c:	4803      	ldr	r0, [pc, #12]	; (800076c <halt+0x38>)
 800075e:	f000 f98d 	bl	8000a7c <print>
 8000762:	e7fe      	b.n	8000762 <halt+0x2e>
 8000764:	20003eec 	.word	0x20003eec
 8000768:	080022a1 	.word	0x080022a1
 800076c:	08002159 	.word	0x08002159

08000770 <u_itoa>:
}

static const char *I_BASE_ARR_L = "0123456789abcdefghijklmnopqrstuvwxyz";
static const char *I_BASE_ARR_U = "0123456789ABCDEFGHIJKLMNOPQRTSUVWXYZ";

static void u_itoa(unsigned int v, char* dst, int base, int num, int flags) {
 8000770:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  // check that the base if valid
  if (base < 2 || base > 36) {
 8000774:	1e94      	subs	r4, r2, #2
 8000776:	2c22      	cmp	r4, #34	; 0x22
}

static const char *I_BASE_ARR_L = "0123456789abcdefghijklmnopqrstuvwxyz";
static const char *I_BASE_ARR_U = "0123456789ABCDEFGHIJKLMNOPQRTSUVWXYZ";

static void u_itoa(unsigned int v, char* dst, int base, int num, int flags) {
 8000778:	9d06      	ldr	r5, [sp, #24]
  // check that the base if valid
  if (base < 2 || base > 36) {
 800077a:	d905      	bls.n	8000788 <u_itoa+0x18>
    if ((flags & ITOA_NO_ZERO_END) == 0) {
 800077c:	f015 0502 	ands.w	r5, r5, #2
 8000780:	d157      	bne.n	8000832 <u_itoa+0xc2>
      *dst = '\0';
 8000782:	700d      	strb	r5, [r1, #0]
 8000784:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    return;
  }

  const char *arr = (flags & ITOA_CAPITALS) ? I_BASE_ARR_U : I_BASE_ARR_L;
 8000788:	4e2b      	ldr	r6, [pc, #172]	; (8000838 <u_itoa+0xc8>)
 800078a:	4c2c      	ldr	r4, [pc, #176]	; (800083c <u_itoa+0xcc>)
 800078c:	f015 0f20 	tst.w	r5, #32
 8000790:	bf14      	ite	ne
 8000792:	46b6      	movne	lr, r6
 8000794:	46a6      	moveq	lr, r4
  char* ptr = dst, *ptr_o = dst, tmp_char;
  int tmp_value;
  int ix = 0;
  char zero_char = flags & ITOA_FILL_SPACE ? ' ' : '0';
 8000796:	f015 0f04 	tst.w	r5, #4
 800079a:	bf0c      	ite	eq
 800079c:	f04f 0830 	moveq.w	r8, #48	; 0x30
 80007a0:	f04f 0820 	movne.w	r8, #32
 80007a4:	1c4e      	adds	r6, r1, #1
  }

  const char *arr = (flags & ITOA_CAPITALS) ? I_BASE_ARR_U : I_BASE_ARR_L;
  char* ptr = dst, *ptr_o = dst, tmp_char;
  int tmp_value;
  int ix = 0;
 80007a6:	2700      	movs	r7, #0
  char zero_char = flags & ITOA_FILL_SPACE ? ' ' : '0';
  do {
    tmp_value = v;
    v /= base;
 80007a8:	fbb0 fcf2 	udiv	ip, r0, r2
    if (tmp_value != 0 || (tmp_value == 0 && ix == 0)) {
      *ptr++ = arr[(tmp_value - v * base)];
 80007ac:	4634      	mov	r4, r6
  int ix = 0;
  char zero_char = flags & ITOA_FILL_SPACE ? ' ' : '0';
  do {
    tmp_value = v;
    v /= base;
    if (tmp_value != 0 || (tmp_value == 0 && ix == 0)) {
 80007ae:	b900      	cbnz	r0, 80007b2 <u_itoa+0x42>
 80007b0:	b937      	cbnz	r7, 80007c0 <u_itoa+0x50>
      *ptr++ = arr[(tmp_value - v * base)];
 80007b2:	fb0c 0012 	mls	r0, ip, r2, r0
 80007b6:	f81e 0000 	ldrb.w	r0, [lr, r0]
 80007ba:	f806 0c01 	strb.w	r0, [r6, #-1]
 80007be:	e001      	b.n	80007c4 <u_itoa+0x54>
    } else {
      *ptr++ = zero_char;
 80007c0:	f806 8c01 	strb.w	r8, [r6, #-1]
    }
    ix++;
 80007c4:	3701      	adds	r7, #1
  } while ((v && num == 0) || (num != 0 && ix < num));
 80007c6:	f1bc 0f00 	cmp.w	ip, #0
 80007ca:	d003      	beq.n	80007d4 <u_itoa+0x64>
 80007cc:	b91b      	cbnz	r3, 80007d6 <u_itoa+0x66>
 80007ce:	3601      	adds	r6, #1
  int tmp_value;
  int ix = 0;
  char zero_char = flags & ITOA_FILL_SPACE ? ' ' : '0';
  do {
    tmp_value = v;
    v /= base;
 80007d0:	4660      	mov	r0, ip
 80007d2:	e7e9      	b.n	80007a8 <u_itoa+0x38>
      *ptr++ = arr[(tmp_value - v * base)];
    } else {
      *ptr++ = zero_char;
    }
    ix++;
  } while ((v && num == 0) || (num != 0 && ix < num));
 80007d4:	b10b      	cbz	r3, 80007da <u_itoa+0x6a>
 80007d6:	429f      	cmp	r7, r3
 80007d8:	dbf9      	blt.n	80007ce <u_itoa+0x5e>

  if (flags & ITOA_BASE_SIG) {
 80007da:	06e8      	lsls	r0, r5, #27
 80007dc:	d511      	bpl.n	8000802 <u_itoa+0x92>
    if (base == 16) {
 80007de:	2a10      	cmp	r2, #16
 80007e0:	d106      	bne.n	80007f0 <u_itoa+0x80>
      *ptr++ = 'x';
 80007e2:	4634      	mov	r4, r6
 80007e4:	2378      	movs	r3, #120	; 0x78
 80007e6:	f804 3b02 	strb.w	r3, [r4], #2
      *ptr++ = '0';
 80007ea:	2330      	movs	r3, #48	; 0x30
 80007ec:	7073      	strb	r3, [r6, #1]
 80007ee:	e008      	b.n	8000802 <u_itoa+0x92>
    } else if (base == 8) {
 80007f0:	2a08      	cmp	r2, #8
 80007f2:	d101      	bne.n	80007f8 <u_itoa+0x88>
      *ptr++ = '0';
 80007f4:	2330      	movs	r3, #48	; 0x30
 80007f6:	e002      	b.n	80007fe <u_itoa+0x8e>
    } else if (base == 2) {
 80007f8:	2a02      	cmp	r2, #2
 80007fa:	d102      	bne.n	8000802 <u_itoa+0x92>
      *ptr++ = 'b';
 80007fc:	2362      	movs	r3, #98	; 0x62
 80007fe:	7033      	strb	r3, [r6, #0]
 8000800:	1c74      	adds	r4, r6, #1
    }
  }

  // apply sign
  if (flags & ITOA_NEGATE) {
 8000802:	07ea      	lsls	r2, r5, #31
 8000804:	d501      	bpl.n	800080a <u_itoa+0x9a>
    *ptr++ = '-';
 8000806:	232d      	movs	r3, #45	; 0x2d
 8000808:	e002      	b.n	8000810 <u_itoa+0xa0>
  } else if (flags & ITOA_FORCE_SIGN) {
 800080a:	072b      	lsls	r3, r5, #28
 800080c:	d502      	bpl.n	8000814 <u_itoa+0xa4>
    *ptr++ = '+';
 800080e:	232b      	movs	r3, #43	; 0x2b
 8000810:	7023      	strb	r3, [r4, #0]
 8000812:	3401      	adds	r4, #1
  }

  // end
  if (flags & ITOA_NO_ZERO_END) {
 8000814:	f015 0502 	ands.w	r5, r5, #2
 8000818:	f104 33ff 	add.w	r3, r4, #4294967295	; 0xffffffff
 800081c:	d100      	bne.n	8000820 <u_itoa+0xb0>
    ptr--;
  } else {
    *ptr-- = '\0';
 800081e:	7025      	strb	r5, [r4, #0]
  }
  while (ptr_o < ptr) {
 8000820:	428b      	cmp	r3, r1
 8000822:	d906      	bls.n	8000832 <u_itoa+0xc2>
    tmp_char = *ptr;
 8000824:	781a      	ldrb	r2, [r3, #0]
    *ptr-- = *ptr_o;
 8000826:	7808      	ldrb	r0, [r1, #0]
 8000828:	f803 0901 	strb.w	r0, [r3], #-1
    *ptr_o++ = tmp_char;
 800082c:	f801 2b01 	strb.w	r2, [r1], #1
 8000830:	e7f6      	b.n	8000820 <u_itoa+0xb0>
 8000832:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000836:	bf00      	nop
 8000838:	080022b2 	.word	0x080022b2
 800083c:	080022d7 	.word	0x080022d7

08000840 <strlen>:
    val = val * base + b;
  }
  return negate ? -val : val;
}

int strlen(const char* c) {
 8000840:	4603      	mov	r3, r0
  const char *s;
  for (s = c; *s; ++s)
 8000842:	781a      	ldrb	r2, [r3, #0]
 8000844:	1c59      	adds	r1, r3, #1
 8000846:	b10a      	cbz	r2, 800084c <strlen+0xc>
 8000848:	460b      	mov	r3, r1
 800084a:	e7fa      	b.n	8000842 <strlen+0x2>
    ;
  return (int) (s - c);
}
 800084c:	1a18      	subs	r0, r3, r0
 800084e:	4770      	bx	lr

08000850 <v_printf>:
// generates string ascii as captials
#define ITOA_CAPITALS           (1<<__ITOA_CAPITALS_B)

static void u_itoa(unsigned int v, char* dst, int base, int num, int flags);

void v_printf(long p, const char* f, va_list arg_p) {
 8000850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  register const char* tmp_f = f;
  register const char* start_f = f;
  char c;
  int format = 0;
  int num = 0;
 8000854:	f04f 0a00 	mov.w	sl, #0
      start_f = tmp_f;
      format = 0;
    } else {
      if (c == '%') {
        if (tmp_f > start_f + 1) {
          PUTB(p, start_f, (int)(tmp_f - start_f - 1));
 8000858:	f8df b21c 	ldr.w	fp, [pc, #540]	; 8000a78 <v_printf+0x228>
// generates string ascii as captials
#define ITOA_CAPITALS           (1<<__ITOA_CAPITALS_B)

static void u_itoa(unsigned int v, char* dst, int base, int num, int flags);

void v_printf(long p, const char* f, va_list arg_p) {
 800085c:	b08d      	sub	sp, #52	; 0x34
 800085e:	4604      	mov	r4, r0
 8000860:	460d      	mov	r5, r1
 8000862:	4616      	mov	r6, r2
  register const char* tmp_f = f;
  register const char* start_f = f;
 8000864:	4688      	mov	r8, r1
  char c;
  int format = 0;
  int num = 0;
  char buf[36];
  int flags = ITOA_FILL_SPACE;
 8000866:	f04f 0904 	mov.w	r9, #4

void v_printf(long p, const char* f, va_list arg_p) {
  register const char* tmp_f = f;
  register const char* start_f = f;
  char c;
  int format = 0;
 800086a:	4657      	mov	r7, sl
  int num = 0;
  char buf[36];
  int flags = ITOA_FILL_SPACE;

  while ((c = *tmp_f++) != 0) {
 800086c:	f815 1b01 	ldrb.w	r1, [r5], #1
 8000870:	2900      	cmp	r1, #0
 8000872:	f000 80e5 	beq.w	8000a40 <v_printf+0x1f0>
    if (format) {
 8000876:	2f00      	cmp	r7, #0
 8000878:	f000 80bf 	beq.w	80009fa <v_printf+0x1aa>
      switch (c) {
 800087c:	2963      	cmp	r1, #99	; 0x63
 800087e:	f000 8081 	beq.w	8000984 <v_printf+0x134>
 8000882:	d818      	bhi.n	80008b6 <v_printf+0x66>
 8000884:	2939      	cmp	r1, #57	; 0x39
 8000886:	d80b      	bhi.n	80008a0 <v_printf+0x50>
 8000888:	2930      	cmp	r1, #48	; 0x30
 800088a:	d22a      	bcs.n	80008e2 <v_printf+0x92>
 800088c:	2925      	cmp	r1, #37	; 0x25
 800088e:	d024      	beq.n	80008da <v_printf+0x8a>
 8000890:	292b      	cmp	r1, #43	; 0x2b
 8000892:	d036      	beq.n	8000902 <v_printf+0xb2>
 8000894:	2923      	cmp	r1, #35	; 0x23
 8000896:	f040 809f 	bne.w	80009d8 <v_printf+0x188>
        continue;
      case '+':
        flags |= ITOA_FORCE_SIGN;
        continue;
      case '#':
        flags |= ITOA_BASE_SIG;
 800089a:	f049 0910 	orr.w	r9, r9, #16
 800089e:	e0cd      	b.n	8000a3c <v_printf+0x1ec>
  char buf[36];
  int flags = ITOA_FILL_SPACE;

  while ((c = *tmp_f++) != 0) {
    if (format) {
      switch (c) {
 80008a0:	2958      	cmp	r1, #88	; 0x58
 80008a2:	d04b      	beq.n	800093c <v_printf+0xec>
 80008a4:	2962      	cmp	r1, #98	; 0x62
 80008a6:	f040 8097 	bne.w	80009d8 <v_printf+0x188>
        u_itoa(va_arg(arg_p, int), &buf[0], 8, num, flags);
        PUTB(p, &buf[0], strlen(&buf[0]));
        break;
      }
      case 'b': {
        u_itoa(va_arg(arg_p, int), &buf[0], 2, num, flags);
 80008aa:	1d37      	adds	r7, r6, #4
 80008ac:	f8cd 9000 	str.w	r9, [sp]
 80008b0:	4653      	mov	r3, sl
 80008b2:	2202      	movs	r2, #2
 80008b4:	e04f      	b.n	8000956 <v_printf+0x106>
  char buf[36];
  int flags = ITOA_FILL_SPACE;

  while ((c = *tmp_f++) != 0) {
    if (format) {
      switch (c) {
 80008b6:	2970      	cmp	r1, #112	; 0x70
 80008b8:	d03b      	beq.n	8000932 <v_printf+0xe2>
 80008ba:	d807      	bhi.n	80008cc <v_printf+0x7c>
 80008bc:	2969      	cmp	r1, #105	; 0x69
 80008be:	d023      	beq.n	8000908 <v_printf+0xb8>
 80008c0:	296f      	cmp	r1, #111	; 0x6f
 80008c2:	d043      	beq.n	800094c <v_printf+0xfc>
 80008c4:	2964      	cmp	r1, #100	; 0x64
 80008c6:	f040 8087 	bne.w	80009d8 <v_printf+0x188>
 80008ca:	e01d      	b.n	8000908 <v_printf+0xb8>
 80008cc:	2975      	cmp	r1, #117	; 0x75
 80008ce:	d02a      	beq.n	8000926 <v_printf+0xd6>
 80008d0:	2978      	cmp	r1, #120	; 0x78
 80008d2:	d035      	beq.n	8000940 <v_printf+0xf0>
 80008d4:	2973      	cmp	r1, #115	; 0x73
 80008d6:	d17f      	bne.n	80009d8 <v_printf+0x188>
 80008d8:	e064      	b.n	80009a4 <v_printf+0x154>
      case '%': {
        PUTC(p, '%');
 80008da:	2cff      	cmp	r4, #255	; 0xff
 80008dc:	dd7f      	ble.n	80009de <v_printf+0x18e>
 80008de:	7021      	strb	r1, [r4, #0]
 80008e0:	e087      	b.n	80009f2 <v_printf+0x1a2>
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        if (c == '0' && num == 0) {
 80008e2:	d104      	bne.n	80008ee <v_printf+0x9e>
 80008e4:	f1ba 0f00 	cmp.w	sl, #0
 80008e8:	d101      	bne.n	80008ee <v_printf+0x9e>
          flags &= ~ITOA_FILL_SPACE;
 80008ea:	f029 0904 	bic.w	r9, r9, #4
        }
        num = num * 10 + (c - '0');
        num = MIN(sizeof(buf)-1, num);
 80008ee:	3930      	subs	r1, #48	; 0x30
 80008f0:	230a      	movs	r3, #10
 80008f2:	fb03 1a0a 	mla	sl, r3, sl, r1
 80008f6:	f1ba 0f23 	cmp.w	sl, #35	; 0x23
 80008fa:	bf28      	it	cs
 80008fc:	f04f 0a23 	movcs.w	sl, #35	; 0x23
 8000900:	e09c      	b.n	8000a3c <v_printf+0x1ec>
        continue;
      case '+':
        flags |= ITOA_FORCE_SIGN;
 8000902:	f049 0908 	orr.w	r9, r9, #8
 8000906:	e099      	b.n	8000a3c <v_printf+0x1ec>
      case '#':
        flags |= ITOA_BASE_SIG;
        continue;
      case 'd':
      case 'i': {
        int v = va_arg(arg_p, int);
 8000908:	6830      	ldr	r0, [r6, #0]
        if (v < 0) {
 800090a:	2800      	cmp	r0, #0
          v = -v;
          flags |= ITOA_NEGATE;
 800090c:	bfb8      	it	lt
 800090e:	f049 0901 	orrlt.w	r9, r9, #1
      case '#':
        flags |= ITOA_BASE_SIG;
        continue;
      case 'd':
      case 'i': {
        int v = va_arg(arg_p, int);
 8000912:	f106 0704 	add.w	r7, r6, #4
        if (v < 0) {
          v = -v;
 8000916:	bfb8      	it	lt
 8000918:	4240      	neglt	r0, r0
          flags |= ITOA_NEGATE;
        }
        u_itoa(v, &buf[0], 10, num, flags);
 800091a:	f8cd 9000 	str.w	r9, [sp]
 800091e:	4653      	mov	r3, sl
 8000920:	220a      	movs	r2, #10
 8000922:	a903      	add	r1, sp, #12
 8000924:	e019      	b.n	800095a <v_printf+0x10a>
        PUTB(p, &buf[0], strlen(&buf[0]));
        break;
      }
      case 'u': {
        u_itoa(va_arg(arg_p, unsigned int), &buf[0], 10, num, flags);
 8000926:	1d37      	adds	r7, r6, #4
 8000928:	f8cd 9000 	str.w	r9, [sp]
 800092c:	4653      	mov	r3, sl
 800092e:	220a      	movs	r2, #10
 8000930:	e011      	b.n	8000956 <v_printf+0x106>
        PUTB(p, &buf[0], strlen(&buf[0]));
        break;
      }
      case 'p': {
        u_itoa(va_arg(arg_p, int), &buf[0], 16, 8, flags);
 8000932:	1d37      	adds	r7, r6, #4
 8000934:	f8cd 9000 	str.w	r9, [sp]
 8000938:	2308      	movs	r3, #8
 800093a:	e005      	b.n	8000948 <v_printf+0xf8>
        PUTB(p, &buf[0], strlen(&buf[0]));
        break;
      }
      case 'X':
        flags |= ITOA_CAPITALS;
 800093c:	f049 0920 	orr.w	r9, r9, #32
        // fall through
        //no break
      case 'x': {
        u_itoa(va_arg(arg_p, int), &buf[0], 16, num, flags);
 8000940:	1d37      	adds	r7, r6, #4
 8000942:	f8cd 9000 	str.w	r9, [sp]
 8000946:	4653      	mov	r3, sl
 8000948:	2210      	movs	r2, #16
 800094a:	e004      	b.n	8000956 <v_printf+0x106>
        PUTB(p, &buf[0], strlen(&buf[0]));
        break;
      }
      case 'o': {
        u_itoa(va_arg(arg_p, int), &buf[0], 8, num, flags);
 800094c:	1d37      	adds	r7, r6, #4
 800094e:	f8cd 9000 	str.w	r9, [sp]
 8000952:	4653      	mov	r3, sl
 8000954:	2208      	movs	r2, #8
        PUTB(p, &buf[0], strlen(&buf[0]));
        break;
      }
      case 'b': {
        u_itoa(va_arg(arg_p, int), &buf[0], 2, num, flags);
 8000956:	6830      	ldr	r0, [r6, #0]
 8000958:	a903      	add	r1, sp, #12
 800095a:	f7ff ff09 	bl	8000770 <u_itoa>
        PUTB(p, &buf[0], strlen(&buf[0]));
 800095e:	2cff      	cmp	r4, #255	; 0xff
 8000960:	a803      	add	r0, sp, #12
 8000962:	dd0a      	ble.n	800097a <v_printf+0x12a>
        if (v < 0) {
          v = -v;
          flags |= ITOA_NEGATE;
        }
        u_itoa(v, &buf[0], 10, num, flags);
        PUTB(p, &buf[0], strlen(&buf[0]));
 8000964:	f7ff ff6c 	bl	8000840 <strlen>
 8000968:	a903      	add	r1, sp, #12
 800096a:	4606      	mov	r6, r0
 800096c:	4602      	mov	r2, r0
 800096e:	4620      	mov	r0, r4
 8000970:	f7ff fc48 	bl	8000204 <memcpy>
 8000974:	4434      	add	r4, r6
      case '#':
        flags |= ITOA_BASE_SIG;
        continue;
      case 'd':
      case 'i': {
        int v = va_arg(arg_p, int);
 8000976:	463e      	mov	r6, r7
 8000978:	e037      	b.n	80009ea <v_printf+0x19a>
        PUTB(p, &buf[0], strlen(&buf[0]));
        break;
      }
      case 'b': {
        u_itoa(va_arg(arg_p, int), &buf[0], 2, num, flags);
        PUTB(p, &buf[0], strlen(&buf[0]));
 800097a:	f7ff ff61 	bl	8000840 <strlen>
 800097e:	a903      	add	r1, sp, #12
 8000980:	b282      	uxth	r2, r0
 8000982:	e018      	b.n	80009b6 <v_printf+0x166>
        break;
      }
      case 'c': {
        int d = va_arg(arg_p, int);
        PUTC(p, d);
 8000984:	2cff      	cmp	r4, #255	; 0xff
        u_itoa(va_arg(arg_p, int), &buf[0], 2, num, flags);
        PUTB(p, &buf[0], strlen(&buf[0]));
        break;
      }
      case 'c': {
        int d = va_arg(arg_p, int);
 8000986:	f106 0704 	add.w	r7, r6, #4
 800098a:	6831      	ldr	r1, [r6, #0]
        PUTC(p, d);
 800098c:	dc07      	bgt.n	800099e <v_printf+0x14e>
 800098e:	f44f 6083 	mov.w	r0, #1048	; 0x418
 8000992:	b2c9      	uxtb	r1, r1
 8000994:	fb00 b004 	mla	r0, r0, r4, fp
 8000998:	f000 f92d 	bl	8000bf6 <UART_put_char>
 800099c:	e7eb      	b.n	8000976 <v_printf+0x126>
 800099e:	7021      	strb	r1, [r4, #0]
        u_itoa(va_arg(arg_p, int), &buf[0], 2, num, flags);
        PUTB(p, &buf[0], strlen(&buf[0]));
        break;
      }
      case 'c': {
        int d = va_arg(arg_p, int);
 80009a0:	463e      	mov	r6, r7
 80009a2:	e026      	b.n	80009f2 <v_printf+0x1a2>
        PUTC(p, d);
        break;
      }
      case 's': {
        char *s = va_arg(arg_p, char*);
 80009a4:	1d37      	adds	r7, r6, #4
 80009a6:	6836      	ldr	r6, [r6, #0]
        PUTB(p, s, strlen(s));
 80009a8:	2cff      	cmp	r4, #255	; 0xff
 80009aa:	4630      	mov	r0, r6
 80009ac:	dc0a      	bgt.n	80009c4 <v_printf+0x174>
 80009ae:	f7ff ff47 	bl	8000840 <strlen>
 80009b2:	4631      	mov	r1, r6
 80009b4:	b282      	uxth	r2, r0
 80009b6:	f44f 6083 	mov.w	r0, #1048	; 0x418
 80009ba:	fb00 b004 	mla	r0, r0, r4, fp
 80009be:	f000 f950 	bl	8000c62 <UART_put_buf>
 80009c2:	e7d8      	b.n	8000976 <v_printf+0x126>
 80009c4:	f7ff ff3c 	bl	8000840 <strlen>
 80009c8:	4631      	mov	r1, r6
 80009ca:	4680      	mov	r8, r0
 80009cc:	4602      	mov	r2, r0
 80009ce:	4620      	mov	r0, r4
 80009d0:	f7ff fc18 	bl	8000204 <memcpy>
 80009d4:	4444      	add	r4, r8
 80009d6:	e7ce      	b.n	8000976 <v_printf+0x126>
        break;
      }
      default:
        PUTC(p, '?');
 80009d8:	2cff      	cmp	r4, #255	; 0xff
 80009da:	dc08      	bgt.n	80009ee <v_printf+0x19e>
 80009dc:	213f      	movs	r1, #63	; 0x3f
 80009de:	f44f 6083 	mov.w	r0, #1048	; 0x418
 80009e2:	fb00 b004 	mla	r0, r0, r4, fp
 80009e6:	f000 f906 	bl	8000bf6 <UART_put_char>
 80009ea:	46a8      	mov	r8, r5
 80009ec:	e003      	b.n	80009f6 <v_printf+0x1a6>
 80009ee:	233f      	movs	r3, #63	; 0x3f
 80009f0:	7023      	strb	r3, [r4, #0]
 80009f2:	46a8      	mov	r8, r5
 80009f4:	3401      	adds	r4, #1
        break;
      }
      start_f = tmp_f;
      format = 0;
 80009f6:	2700      	movs	r7, #0
 80009f8:	e738      	b.n	800086c <v_printf+0x1c>
    } else {
      if (c == '%') {
 80009fa:	2925      	cmp	r1, #37	; 0x25
 80009fc:	f47f af36 	bne.w	800086c <v_printf+0x1c>
        if (tmp_f > start_f + 1) {
 8000a00:	f108 0301 	add.w	r3, r8, #1
 8000a04:	429d      	cmp	r5, r3
 8000a06:	d916      	bls.n	8000a36 <v_printf+0x1e6>
          PUTB(p, start_f, (int)(tmp_f - start_f - 1));
 8000a08:	2cff      	cmp	r4, #255	; 0xff
 8000a0a:	ebc8 0905 	rsb	r9, r8, r5
 8000a0e:	dc0a      	bgt.n	8000a26 <v_printf+0x1d6>
 8000a10:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
 8000a14:	f44f 6083 	mov.w	r0, #1048	; 0x418
 8000a18:	b292      	uxth	r2, r2
 8000a1a:	4641      	mov	r1, r8
 8000a1c:	fb00 b004 	mla	r0, r0, r4, fp
 8000a20:	f000 f91f 	bl	8000c62 <UART_put_buf>
 8000a24:	e007      	b.n	8000a36 <v_printf+0x1e6>
 8000a26:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
 8000a2a:	4620      	mov	r0, r4
 8000a2c:	464a      	mov	r2, r9
 8000a2e:	4641      	mov	r1, r8
 8000a30:	f7ff fbe8 	bl	8000204 <memcpy>
 8000a34:	444c      	add	r4, r9
        }
        num = 0;
        format = 1;
        flags = ITOA_FILL_SPACE;
 8000a36:	f04f 0904 	mov.w	r9, #4
    } else {
      if (c == '%') {
        if (tmp_f > start_f + 1) {
          PUTB(p, start_f, (int)(tmp_f - start_f - 1));
        }
        num = 0;
 8000a3a:	46ba      	mov	sl, r7
        format = 1;
 8000a3c:	2701      	movs	r7, #1
 8000a3e:	e715      	b.n	800086c <v_printf+0x1c>
        flags = ITOA_FILL_SPACE;
      }
    }
  }
  if (tmp_f > start_f + 1) {
 8000a40:	f108 0301 	add.w	r3, r8, #1
 8000a44:	429d      	cmp	r5, r3
 8000a46:	d913      	bls.n	8000a70 <v_printf+0x220>
 8000a48:	ebc8 0205 	rsb	r2, r8, r5
    PUTB(p, start_f, (int)(tmp_f - start_f - 1));
 8000a4c:	2cff      	cmp	r4, #255	; 0xff
 8000a4e:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
 8000a52:	dc09      	bgt.n	8000a68 <v_printf+0x218>
 8000a54:	4b08      	ldr	r3, [pc, #32]	; (8000a78 <v_printf+0x228>)
 8000a56:	f44f 6083 	mov.w	r0, #1048	; 0x418
 8000a5a:	b292      	uxth	r2, r2
 8000a5c:	4641      	mov	r1, r8
 8000a5e:	fb00 3004 	mla	r0, r0, r4, r3
 8000a62:	f000 f8fe 	bl	8000c62 <UART_put_buf>
 8000a66:	e003      	b.n	8000a70 <v_printf+0x220>
 8000a68:	4641      	mov	r1, r8
 8000a6a:	4620      	mov	r0, r4
 8000a6c:	f7ff fbca 	bl	8000204 <memcpy>
  }
}
 8000a70:	b00d      	add	sp, #52	; 0x34
 8000a72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000a76:	bf00      	nop
 8000a78:	20003eec 	.word	0x20003eec

08000a7c <print>:
  v_printf(io, f, arg_p);
  va_end(arg_p);
}

#ifndef print
void print(const char* f, ...) {
 8000a7c:	b40f      	push	{r0, r1, r2, r3}
 8000a7e:	b507      	push	{r0, r1, r2, lr}
 8000a80:	aa04      	add	r2, sp, #16
  va_list arg_p;
  va_start(arg_p, f);
  v_printf(IOSTD, f, arg_p);
 8000a82:	2000      	movs	r0, #0
  v_printf(io, f, arg_p);
  va_end(arg_p);
}

#ifndef print
void print(const char* f, ...) {
 8000a84:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list arg_p;
  va_start(arg_p, f);
 8000a88:	9201      	str	r2, [sp, #4]
  v_printf(IOSTD, f, arg_p);
 8000a8a:	f7ff fee1 	bl	8000850 <v_printf>
  va_end(arg_p);
}
 8000a8e:	b003      	add	sp, #12
 8000a90:	f85d eb04 	ldr.w	lr, [sp], #4
 8000a94:	b004      	add	sp, #16
 8000a96:	4770      	bx	lr

08000a98 <vprint>:
    ioprint(io, "\n");
  }
}

void vprint(const char* f, va_list arg_p) {
  v_printf(IOSTD, f, arg_p);
 8000a98:	460a      	mov	r2, r1
 8000a9a:	4601      	mov	r1, r0
 8000a9c:	2000      	movs	r0, #0
 8000a9e:	f7ff bed7 	b.w	8000850 <v_printf>

08000aa2 <UART_irq>:
#define UART_IS_RX_IRQ_ON(u)  (UART_HW(u)->CR1 & USART_CR1_RXNEIE)
#define UART_IS_TX_IRQ_ON(u)  (UART_HW(u)->CR1 & USART_CR1_TXEIE)

void UART_irq(uart *u) {

  if (u->hw == NULL) return;
 8000aa2:	6803      	ldr	r3, [r0, #0]
#define UART_SET_TX_IRQ_OFF(u) UART_HW(u)->CR1 &= ~USART_CR1_TXEIE
#define UART_SET_TX_IRQ_ON(u)  UART_HW(u)->CR1 |= USART_CR1_TXEIE
#define UART_IS_RX_IRQ_ON(u)  (UART_HW(u)->CR1 & USART_CR1_RXNEIE)
#define UART_IS_TX_IRQ_ON(u)  (UART_HW(u)->CR1 & USART_CR1_TXEIE)

void UART_irq(uart *u) {
 8000aa4:	b510      	push	{r4, lr}
 8000aa6:	4604      	mov	r4, r0

  if (u->hw == NULL) return;
 8000aa8:	2b00      	cmp	r3, #0
 8000aaa:	d059      	beq.n	8000b60 <UART_irq+0xbe>

  if (UART_CHECK_RX(u) && UART_IS_RX_IRQ_ON(u)) {
 8000aac:	69da      	ldr	r2, [r3, #28]
 8000aae:	0690      	lsls	r0, r2, #26
 8000ab0:	d520      	bpl.n	8000af4 <UART_irq+0x52>
 8000ab2:	681a      	ldr	r2, [r3, #0]
 8000ab4:	0691      	lsls	r1, r2, #26
 8000ab6:	d51d      	bpl.n	8000af4 <UART_irq+0x52>
    u8_t c = UART_HW(u)->RDR;
 8000ab8:	6a59      	ldr	r1, [r3, #36]	; 0x24
    u->rx.buf[u->rx.wix++] = c;
 8000aba:	f8b4 2204 	ldrh.w	r2, [r4, #516]	; 0x204
 8000abe:	b292      	uxth	r2, r2
 8000ac0:	1c50      	adds	r0, r2, #1
 8000ac2:	4422      	add	r2, r4
void UART_irq(uart *u) {

  if (u->hw == NULL) return;

  if (UART_CHECK_RX(u) && UART_IS_RX_IRQ_ON(u)) {
    u8_t c = UART_HW(u)->RDR;
 8000ac4:	b2c9      	uxtb	r1, r1
    u->rx.buf[u->rx.wix++] = c;
 8000ac6:	b280      	uxth	r0, r0
 8000ac8:	f8a4 0204 	strh.w	r0, [r4, #516]	; 0x204
 8000acc:	7111      	strb	r1, [r2, #4]
    if (u->rx.wix >= UART_RX_BUFFER) {
 8000ace:	f8b4 2204 	ldrh.w	r2, [r4, #516]	; 0x204
 8000ad2:	b292      	uxth	r2, r2
 8000ad4:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
      u->rx.wix = 0;
 8000ad8:	bf24      	itt	cs
 8000ada:	2200      	movcs	r2, #0
 8000adc:	f8a4 2204 	strhcs.w	r2, [r4, #516]	; 0x204
    }
    // not needed acc to spec
    __HAL_UART_SEND_REQ(UART_HW(u), UART_RXDATA_FLUSH_REQUEST);
 8000ae0:	699a      	ldr	r2, [r3, #24]
 8000ae2:	f042 0208 	orr.w	r2, r2, #8
 8000ae6:	619a      	str	r2, [r3, #24]

    if (u->rx_f) {
 8000ae8:	f8d4 340c 	ldr.w	r3, [r4, #1036]	; 0x40c
 8000aec:	b113      	cbz	r3, 8000af4 <UART_irq+0x52>
      u->rx_f(u->arg, c);
 8000aee:	f8d4 0410 	ldr.w	r0, [r4, #1040]	; 0x410
 8000af2:	4798      	blx	r3
    }

  }
  if (UART_CHECK_TX(u)) {
 8000af4:	6823      	ldr	r3, [r4, #0]
 8000af6:	69da      	ldr	r2, [r3, #28]
 8000af8:	0612      	lsls	r2, r2, #24
 8000afa:	d531      	bpl.n	8000b60 <UART_irq+0xbe>
    if (UART_ALWAYS_SYNC_TX || u->sync_tx) {
 8000afc:	f894 0415 	ldrb.w	r0, [r4, #1045]	; 0x415
 8000b00:	bb50      	cbnz	r0, 8000b58 <UART_irq+0xb6>
      //_UART_DISABLE_IT(UART_HW(u), USART_IT_TXE);
      //UART_SET_TX_IRQ_OFF(u);
      _UART_DISABLE_IT(UART_HW(u), USART_IT_TC);
    } else {
      if (u->tx.wix != u->tx.rix) {
 8000b02:	f8b4 1408 	ldrh.w	r1, [r4, #1032]	; 0x408
 8000b06:	f8b4 240a 	ldrh.w	r2, [r4, #1034]	; 0x40a
 8000b0a:	b289      	uxth	r1, r1
 8000b0c:	b292      	uxth	r2, r2
 8000b0e:	4291      	cmp	r1, r2
 8000b10:	d012      	beq.n	8000b38 <UART_irq+0x96>
        UART_HW(u)->TDR = u->tx.buf[u->tx.rix++];
 8000b12:	f8b4 240a 	ldrh.w	r2, [r4, #1034]	; 0x40a
 8000b16:	b292      	uxth	r2, r2
 8000b18:	1c51      	adds	r1, r2, #1
 8000b1a:	b289      	uxth	r1, r1
 8000b1c:	4422      	add	r2, r4
 8000b1e:	f8a4 140a 	strh.w	r1, [r4, #1034]	; 0x40a
 8000b22:	f892 2208 	ldrb.w	r2, [r2, #520]	; 0x208
 8000b26:	629a      	str	r2, [r3, #40]	; 0x28
        if (u->tx.rix >= UART_TX_BUFFER) {
 8000b28:	f8b4 240a 	ldrh.w	r2, [r4, #1034]	; 0x40a
 8000b2c:	b292      	uxth	r2, r2
 8000b2e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
          u->tx.rix = 0;
 8000b32:	bf28      	it	cs
 8000b34:	f8a4 040a 	strhcs.w	r0, [r4, #1034]	; 0x40a
        }
      }
      if (u->tx.wix == u->tx.rix) {
 8000b38:	f8b4 1408 	ldrh.w	r1, [r4, #1032]	; 0x408
 8000b3c:	f8b4 240a 	ldrh.w	r2, [r4, #1034]	; 0x40a
 8000b40:	b289      	uxth	r1, r1
 8000b42:	b292      	uxth	r2, r2
 8000b44:	4291      	cmp	r1, r2
 8000b46:	d10b      	bne.n	8000b60 <UART_irq+0xbe>
        UART_SET_TX_IRQ_OFF(u);
 8000b48:	681a      	ldr	r2, [r3, #0]
 8000b4a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8000b4e:	601a      	str	r2, [r3, #0]
        _UART_DISABLE_IT(UART_HW(u), USART_IT_TXE);
 8000b50:	681a      	ldr	r2, [r3, #0]
 8000b52:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8000b56:	601a      	str	r2, [r3, #0]
        _UART_DISABLE_IT(UART_HW(u), USART_IT_TC);
 8000b58:	681a      	ldr	r2, [r3, #0]
 8000b5a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8000b5e:	601a      	str	r2, [r3, #0]
 8000b60:	bd10      	pop	{r4, pc}

08000b62 <UART_tx_available>:
    return w + UART_RX_BUFFER - r;
  }
}

u16_t UART_tx_available(uart *u) {
  volatile u16_t r = u->tx.rix;
 8000b62:	f8b0 340a 	ldrh.w	r3, [r0, #1034]	; 0x40a
  } else {
    return w + UART_RX_BUFFER - r;
  }
}

u16_t UART_tx_available(uart *u) {
 8000b66:	b082      	sub	sp, #8
  volatile u16_t r = u->tx.rix;
 8000b68:	b29b      	uxth	r3, r3
 8000b6a:	f8ad 3004 	strh.w	r3, [sp, #4]
  volatile u16_t w = u->tx.wix;
 8000b6e:	f8b0 3408 	ldrh.w	r3, [r0, #1032]	; 0x408
 8000b72:	b29b      	uxth	r3, r3
 8000b74:	f8ad 3006 	strh.w	r3, [sp, #6]
  if (w > r) {
 8000b78:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8000b7c:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    return UART_TX_BUFFER - (w - r) - 1;
 8000b80:	f8bd 0004 	ldrh.w	r0, [sp, #4]
}

u16_t UART_tx_available(uart *u) {
  volatile u16_t r = u->tx.rix;
  volatile u16_t w = u->tx.wix;
  if (w > r) {
 8000b84:	b292      	uxth	r2, r2
 8000b86:	b29b      	uxth	r3, r3
 8000b88:	429a      	cmp	r2, r3
    return UART_TX_BUFFER - (w - r) - 1;
 8000b8a:	b280      	uxth	r0, r0
 8000b8c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8000b90:	bf8c      	ite	hi
 8000b92:	f200 10ff 	addwhi	r0, r0, #511	; 0x1ff
  } else {
    return UART_TX_BUFFER - (w + UART_TX_BUFFER - r) - 1;
 8000b96:	f100 30ff 	addls.w	r0, r0, #4294967295	; 0xffffffff
 8000b9a:	1ac0      	subs	r0, r0, r3
 8000b9c:	b280      	uxth	r0, r0
  }
}
 8000b9e:	b002      	add	sp, #8
 8000ba0:	4770      	bx	lr

08000ba2 <UART_tx_force_char>:
    return res;
  }
}

void UART_tx_force_char(uart *u, u8_t c) {
  while (UART_CHECK_TX(u) == 0)
 8000ba2:	6803      	ldr	r3, [r0, #0]
 8000ba4:	69da      	ldr	r2, [r3, #28]
 8000ba6:	0612      	lsls	r2, r2, #24
 8000ba8:	d5fc      	bpl.n	8000ba4 <UART_tx_force_char+0x2>
    ;
  UART_HW(u)->TDR = (uint8_t) c;
 8000baa:	6299      	str	r1, [r3, #40]	; 0x28
 8000bac:	4770      	bx	lr

08000bae <UART_tx_flush>:
  uart->tx.wix = 0;
#endif
}

void UART_tx_flush(uart *u) {
  UART_SET_RX_IRQ_OFF(u);
 8000bae:	6802      	ldr	r2, [r0, #0]
 8000bb0:	6813      	ldr	r3, [r2, #0]
 8000bb2:	f023 0320 	bic.w	r3, r3, #32
  uart->tx.rix = 0;
  uart->tx.wix = 0;
#endif
}

void UART_tx_flush(uart *u) {
 8000bb6:	b570      	push	{r4, r5, r6, lr}
  UART_SET_RX_IRQ_OFF(u);
 8000bb8:	6013      	str	r3, [r2, #0]
  u16_t rix = u->tx.rix;
 8000bba:	f8b0 440a 	ldrh.w	r4, [r0, #1034]	; 0x40a
  u16_t wix = u->tx.wix;
 8000bbe:	f8b0 6408 	ldrh.w	r6, [r0, #1032]	; 0x408
  uart->tx.rix = 0;
  uart->tx.wix = 0;
#endif
}

void UART_tx_flush(uart *u) {
 8000bc2:	4605      	mov	r5, r0
  UART_SET_RX_IRQ_OFF(u);
  u16_t rix = u->tx.rix;
 8000bc4:	b2a4      	uxth	r4, r4
  u16_t wix = u->tx.wix;
 8000bc6:	b2b6      	uxth	r6, r6
  while (rix != wix) {
 8000bc8:	42b4      	cmp	r4, r6
 8000bca:	d00c      	beq.n	8000be6 <UART_tx_flush+0x38>
    u8_t c = u->tx.buf[rix];
 8000bcc:	192b      	adds	r3, r5, r4
    UART_tx_force_char(u, c);
 8000bce:	4628      	mov	r0, r5
 8000bd0:	f893 1208 	ldrb.w	r1, [r3, #520]	; 0x208
 8000bd4:	f7ff ffe5 	bl	8000ba2 <UART_tx_force_char>
    if (rix >= UART_RX_BUFFER - 1) {
 8000bd8:	f5b4 7fff 	cmp.w	r4, #510	; 0x1fe
      rix = 0;
    } else {
      rix++;
 8000bdc:	bf9a      	itte	ls
 8000bde:	3401      	addls	r4, #1
 8000be0:	b2a4      	uxthls	r4, r4
  u16_t wix = u->tx.wix;
  while (rix != wix) {
    u8_t c = u->tx.buf[rix];
    UART_tx_force_char(u, c);
    if (rix >= UART_RX_BUFFER - 1) {
      rix = 0;
 8000be2:	2400      	movhi	r4, #0
 8000be4:	e7f0      	b.n	8000bc8 <UART_tx_flush+0x1a>
    } else {
      rix++;
    }
  }
  u->tx.rix = rix;
  UART_SET_RX_IRQ_ON(u);
 8000be6:	682a      	ldr	r2, [r5, #0]
      rix = 0;
    } else {
      rix++;
    }
  }
  u->tx.rix = rix;
 8000be8:	f8a5 440a 	strh.w	r4, [r5, #1034]	; 0x40a
  UART_SET_RX_IRQ_ON(u);
 8000bec:	6813      	ldr	r3, [r2, #0]
 8000bee:	f043 0320 	orr.w	r3, r3, #32
 8000bf2:	6013      	str	r3, [r2, #0]
 8000bf4:	bd70      	pop	{r4, r5, r6, pc}

08000bf6 <UART_put_char>:

  UART_SET_RX_IRQ_ON(u);
  return len_to_read;
}

s32_t UART_put_char(uart *u, u8_t c) {
 8000bf6:	b570      	push	{r4, r5, r6, lr}
  if (UART_ALWAYS_SYNC_TX || u->sync_tx) {
 8000bf8:	f890 3415 	ldrb.w	r3, [r0, #1045]	; 0x415

  UART_SET_RX_IRQ_ON(u);
  return len_to_read;
}

s32_t UART_put_char(uart *u, u8_t c) {
 8000bfc:	4604      	mov	r4, r0
 8000bfe:	460e      	mov	r6, r1
  if (UART_ALWAYS_SYNC_TX || u->sync_tx) {
 8000c00:	b11b      	cbz	r3, 8000c0a <UART_put_char+0x14>
    UART_tx_force_char(u, c);
 8000c02:	f7ff ffce 	bl	8000ba2 <UART_tx_force_char>
    return 0;
 8000c06:	2000      	movs	r0, #0
 8000c08:	bd70      	pop	{r4, r5, r6, pc}
 8000c0a:	f44f 3580 	mov.w	r5, #65536	; 0x10000
 8000c0e:	4619      	mov	r1, r3
    s32_t res;
    int max_tries = 0x10000;
    do {
      res = 0;

      if (UART_tx_available(u) > 0) {
 8000c10:	4620      	mov	r0, r4
 8000c12:	f7ff ffa6 	bl	8000b62 <UART_tx_available>
 8000c16:	b190      	cbz	r0, 8000c3e <UART_put_char+0x48>
        u->tx.buf[u->tx.wix++] = c;
 8000c18:	f8b4 3408 	ldrh.w	r3, [r4, #1032]	; 0x408
 8000c1c:	b29b      	uxth	r3, r3
 8000c1e:	1c5a      	adds	r2, r3, #1
 8000c20:	4423      	add	r3, r4
 8000c22:	b292      	uxth	r2, r2
 8000c24:	f8a4 2408 	strh.w	r2, [r4, #1032]	; 0x408
 8000c28:	f883 6208 	strb.w	r6, [r3, #520]	; 0x208
        if (u->tx.wix >= UART_TX_BUFFER) {
 8000c2c:	f8b4 3408 	ldrh.w	r3, [r4, #1032]	; 0x408
 8000c30:	b29b      	uxth	r3, r3
 8000c32:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000c36:	d305      	bcc.n	8000c44 <UART_put_char+0x4e>
          u->tx.wix = 0;
 8000c38:	f8a4 1408 	strh.w	r1, [r4, #1032]	; 0x408
 8000c3c:	e002      	b.n	8000c44 <UART_put_char+0x4e>
        }
      } else {
        res = -1;
 8000c3e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000c42:	e000      	b.n	8000c46 <UART_put_char+0x50>
    return 0;
  } else {
    s32_t res;
    int max_tries = 0x10000;
    do {
      res = 0;
 8000c44:	2000      	movs	r0, #0
          u->tx.wix = 0;
        }
      } else {
        res = -1;
      }
      UART_SET_TX_IRQ_ON(u);
 8000c46:	6822      	ldr	r2, [r4, #0]
 8000c48:	6813      	ldr	r3, [r2, #0]
 8000c4a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000c4e:	6013      	str	r3, [r2, #0]
    } while (u->assure_tx && res != 0 && --max_tries > 0);
 8000c50:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 8000c54:	b123      	cbz	r3, 8000c60 <UART_put_char+0x6a>
 8000c56:	b118      	cbz	r0, 8000c60 <UART_put_char+0x6a>
 8000c58:	3d01      	subs	r5, #1
 8000c5a:	d1d9      	bne.n	8000c10 <UART_put_char+0x1a>
 8000c5c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    return res;
  }
}
 8000c60:	bd70      	pop	{r4, r5, r6, pc}

08000c62 <UART_put_buf>:
  while (UART_CHECK_TX(u) == 0)
    ;
  UART_HW(u)->TDR = (uint8_t) c;
}

s32_t UART_put_buf(uart *u, u8_t* c, u16_t len) {
 8000c62:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000c66:	4604      	mov	r4, r0
  if (UART_ALWAYS_SYNC_TX || u->sync_tx) {
 8000c68:	f890 0415 	ldrb.w	r0, [r0, #1045]	; 0x415
  while (UART_CHECK_TX(u) == 0)
    ;
  UART_HW(u)->TDR = (uint8_t) c;
}

s32_t UART_put_buf(uart *u, u8_t* c, u16_t len) {
 8000c6c:	460f      	mov	r7, r1
 8000c6e:	4691      	mov	r9, r2
  if (UART_ALWAYS_SYNC_TX || u->sync_tx) {
 8000c70:	b158      	cbz	r0, 8000c8a <UART_put_buf+0x28>
 8000c72:	188d      	adds	r5, r1, r2
    u16_t tlen = len;
    while (tlen-- > 0) {
 8000c74:	42af      	cmp	r7, r5
 8000c76:	d005      	beq.n	8000c84 <UART_put_buf+0x22>
      UART_put_char(u, *c++);
 8000c78:	f817 1b01 	ldrb.w	r1, [r7], #1
 8000c7c:	4620      	mov	r0, r4
 8000c7e:	f7ff ffba 	bl	8000bf6 <UART_put_char>
 8000c82:	e7f7      	b.n	8000c74 <UART_put_buf+0x12>
    }
    return len;
 8000c84:	4648      	mov	r0, r9
 8000c86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c8a:	4606      	mov	r6, r0
      u32_t len_to_end = UART_TX_BUFFER - u->tx.wix;
      if (remaining > len_to_end) {
        memcpy(&u->tx.buf[u->tx.wix], c, len_to_end);
        c += len_to_end;
        remaining -= len_to_end;
        u->tx.wix = 0;
 8000c8c:	4682      	mov	sl, r0
    return len;
  } else {
    u32_t written = 0;
    u16_t guard = 0;
    do {
      u16_t avail = UART_tx_available(u);
 8000c8e:	4620      	mov	r0, r4
 8000c90:	f7ff ff67 	bl	8000b62 <UART_tx_available>
      s32_t len_to_write = MIN(len - written, avail);
 8000c94:	ebc6 0809 	rsb	r8, r6, r9
 8000c98:	4540      	cmp	r0, r8
 8000c9a:	bf28      	it	cs
 8000c9c:	4640      	movcs	r0, r8
      guard++;
      if (len_to_write == 0) {
 8000c9e:	b108      	cbz	r0, 8000ca4 <UART_put_buf+0x42>
  } else {
    u32_t written = 0;
    u16_t guard = 0;
    do {
      u16_t avail = UART_tx_available(u);
      s32_t len_to_write = MIN(len - written, avail);
 8000ca0:	4680      	mov	r8, r0
 8000ca2:	e005      	b.n	8000cb0 <UART_put_buf+0x4e>
      guard++;
      if (len_to_write == 0) {
        while (UART_CHECK_TX(u) == 0)
 8000ca4:	6822      	ldr	r2, [r4, #0]
 8000ca6:	69d3      	ldr	r3, [r2, #28]
 8000ca8:	061b      	lsls	r3, r3, #24
 8000caa:	d5fc      	bpl.n	8000ca6 <UART_put_buf+0x44>
          ;
        len_to_write = 1;
 8000cac:	f04f 0801 	mov.w	r8, #1
      }
      guard = 0;
      u32_t remaining = len_to_write;
      u32_t len_to_end = UART_TX_BUFFER - u->tx.wix;
 8000cb0:	f8b4 5408 	ldrh.w	r5, [r4, #1032]	; 0x408
 8000cb4:	b2ad      	uxth	r5, r5
 8000cb6:	f5c5 7500 	rsb	r5, r5, #512	; 0x200
      if (remaining > len_to_end) {
 8000cba:	45a8      	cmp	r8, r5
 8000cbc:	d90f      	bls.n	8000cde <UART_put_buf+0x7c>
        memcpy(&u->tx.buf[u->tx.wix], c, len_to_end);
 8000cbe:	f8b4 0408 	ldrh.w	r0, [r4, #1032]	; 0x408
 8000cc2:	b280      	uxth	r0, r0
 8000cc4:	f500 7002 	add.w	r0, r0, #520	; 0x208
 8000cc8:	462a      	mov	r2, r5
 8000cca:	4639      	mov	r1, r7
 8000ccc:	4420      	add	r0, r4
 8000cce:	f7ff fa99 	bl	8000204 <memcpy>
        c += len_to_end;
 8000cd2:	442f      	add	r7, r5
        remaining -= len_to_end;
        u->tx.wix = 0;
 8000cd4:	f8a4 a408 	strh.w	sl, [r4, #1032]	; 0x408
      u32_t remaining = len_to_write;
      u32_t len_to_end = UART_TX_BUFFER - u->tx.wix;
      if (remaining > len_to_end) {
        memcpy(&u->tx.buf[u->tx.wix], c, len_to_end);
        c += len_to_end;
        remaining -= len_to_end;
 8000cd8:	ebc5 0508 	rsb	r5, r5, r8
 8000cdc:	e000      	b.n	8000ce0 <UART_put_buf+0x7e>
 8000cde:	4645      	mov	r5, r8
        u->tx.wix = 0;
      }
      memcpy(&u->tx.buf[u->tx.wix], c, remaining);
 8000ce0:	f8b4 0408 	ldrh.w	r0, [r4, #1032]	; 0x408
 8000ce4:	b280      	uxth	r0, r0
 8000ce6:	f500 7002 	add.w	r0, r0, #520	; 0x208
 8000cea:	462a      	mov	r2, r5
 8000cec:	4639      	mov	r1, r7
 8000cee:	4420      	add	r0, r4
 8000cf0:	f7ff fa88 	bl	8000204 <memcpy>
      c += remaining;
      u->tx.wix += remaining;
 8000cf4:	f8b4 3408 	ldrh.w	r3, [r4, #1032]	; 0x408
      if (u->tx.wix >= UART_RX_BUFFER) {
        u->tx.wix = 0;
      }
      UART_SET_TX_IRQ_ON(u);
 8000cf8:	6822      	ldr	r2, [r4, #0]
        c += len_to_end;
        remaining -= len_to_end;
        u->tx.wix = 0;
      }
      memcpy(&u->tx.buf[u->tx.wix], c, remaining);
      c += remaining;
 8000cfa:	442f      	add	r7, r5
      u->tx.wix += remaining;
 8000cfc:	fa15 f583 	uxtah	r5, r5, r3
 8000d00:	b2ad      	uxth	r5, r5
 8000d02:	f8a4 5408 	strh.w	r5, [r4, #1032]	; 0x408
      if (u->tx.wix >= UART_RX_BUFFER) {
 8000d06:	f8b4 3408 	ldrh.w	r3, [r4, #1032]	; 0x408
 8000d0a:	b29b      	uxth	r3, r3
 8000d0c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
        u->tx.wix = 0;
 8000d10:	bf28      	it	cs
 8000d12:	f8a4 a408 	strhcs.w	sl, [r4, #1032]	; 0x408
      }
      UART_SET_TX_IRQ_ON(u);
 8000d16:	6813      	ldr	r3, [r2, #0]
 8000d18:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000d1c:	6013      	str	r3, [r2, #0]
      written += len_to_write;
    } while (u->assure_tx && written < len && guard < 0xff);
 8000d1e:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
      u->tx.wix += remaining;
      if (u->tx.wix >= UART_RX_BUFFER) {
        u->tx.wix = 0;
      }
      UART_SET_TX_IRQ_ON(u);
      written += len_to_write;
 8000d22:	4446      	add	r6, r8
    } while (u->assure_tx && written < len && guard < 0xff);
 8000d24:	b913      	cbnz	r3, 8000d2c <UART_put_buf+0xca>

    return written;
 8000d26:	4630      	mov	r0, r6
 8000d28:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if (u->tx.wix >= UART_RX_BUFFER) {
        u->tx.wix = 0;
      }
      UART_SET_TX_IRQ_ON(u);
      written += len_to_write;
    } while (u->assure_tx && written < len && guard < 0xff);
 8000d2c:	45b1      	cmp	r9, r6
 8000d2e:	d8ae      	bhi.n	8000c8e <UART_put_buf+0x2c>
 8000d30:	e7f9      	b.n	8000d26 <UART_put_buf+0xc4>

08000d32 <UART_set_callback>:
    return written;
  }
}

void UART_set_callback(uart *u, uart_rx_callback rx_f, void* arg) {
  u->rx_f = rx_f;
 8000d32:	f8c0 140c 	str.w	r1, [r0, #1036]	; 0x40c
  u->arg = arg;
 8000d36:	f8c0 2410 	str.w	r2, [r0, #1040]	; 0x410
 8000d3a:	4770      	bx	lr

08000d3c <UART_assure_tx>:
  *arg = u->arg;
}

uart __uart_vec[CONFIG_UART_CNT];

bool UART_assure_tx(uart *u, bool on) {
 8000d3c:	4603      	mov	r3, r0
  bool old = u->assure_tx;
 8000d3e:	f890 0414 	ldrb.w	r0, [r0, #1044]	; 0x414
  u->assure_tx = on;
 8000d42:	f883 1414 	strb.w	r1, [r3, #1044]	; 0x414
  return old;
}
 8000d46:	4770      	bx	lr

08000d48 <UART_sync_tx>:

bool UART_sync_tx(uart *u, bool on) {
 8000d48:	4603      	mov	r3, r0
  bool old = u->sync_tx;
 8000d4a:	f890 0415 	ldrb.w	r0, [r0, #1045]	; 0x415
  u->sync_tx = on;
 8000d4e:	f883 1415 	strb.w	r1, [r3, #1045]	; 0x415
  return old;
}
 8000d52:	4770      	bx	lr

08000d54 <UART_config>:

bool UART_config(uart *uart, u32_t baud, UART_databits databits,
    UART_stopbits stopbits, UART_parity parity, UART_flowcontrol flowcontrol,
    bool activate) {
 8000d54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  UART_HW(uart)->CR1 &= ~USART_CR1_UE; // disable uart
 8000d56:	6804      	ldr	r4, [r0, #0]
  return old;
}

bool UART_config(uart *uart, u32_t baud, UART_databits databits,
    UART_stopbits stopbits, UART_parity parity, UART_flowcontrol flowcontrol,
    bool activate) {
 8000d58:	f89d 7018 	ldrb.w	r7, [sp, #24]
 8000d5c:	f89d e01c 	ldrb.w	lr, [sp, #28]
 8000d60:	460e      	mov	r6, r1
  UART_HW(uart)->CR1 &= ~USART_CR1_UE; // disable uart
 8000d62:	6821      	ldr	r1, [r4, #0]
 8000d64:	f021 0101 	bic.w	r1, r1, #1
 8000d68:	6021      	str	r1, [r4, #0]

  if (activate) {
 8000d6a:	f89d 1020 	ldrb.w	r1, [sp, #32]
  return old;
}

bool UART_config(uart *uart, u32_t baud, UART_databits databits,
    UART_stopbits stopbits, UART_parity parity, UART_flowcontrol flowcontrol,
    bool activate) {
 8000d6e:	4605      	mov	r5, r0
  UART_HW(uart)->CR1 &= ~USART_CR1_UE; // disable uart

  if (activate) {
 8000d70:	2900      	cmp	r1, #0
 8000d72:	f000 810b 	beq.w	8000f8c <UART_config+0x238>
    u32_t sparity = 0;
    u32_t sflowcontrol = 0;
    uint16_t usartdiv                   = 0x0000;

    UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
    switch (databits) {
 8000d76:	b122      	cbz	r2, 8000d82 <UART_config+0x2e>
 8000d78:	2a09      	cmp	r2, #9
 8000d7a:	f040 8119 	bne.w	8000fb0 <UART_config+0x25c>
    case UART_DATABITS_8: sdatabits = USART_WORDLENGTH_8B; break;
    case UART_DATABITS_9: sdatabits = USART_WORDLENGTH_9B; break;
 8000d7e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    default: return FALSE;
    }
    switch (stopbits) {
 8000d82:	2b03      	cmp	r3, #3
 8000d84:	f200 8114 	bhi.w	8000fb0 <UART_config+0x25c>
 8000d88:	e8df f003 	tbb	[pc, r3]
 8000d8c:	05020808 	.word	0x05020808
    case UART_STOPBITS_0_5: sstopbits = USART_STOPBITS_1; break;
    case UART_STOPBITS_1: sstopbits = USART_STOPBITS_1; break;
    case UART_STOPBITS_1_5: sstopbits = USART_STOPBITS_1_5; break;
 8000d90:	f44f 5040 	mov.w	r0, #12288	; 0x3000
 8000d94:	e003      	b.n	8000d9e <UART_config+0x4a>
    case UART_STOPBITS_2: sstopbits = USART_STOPBITS_2; break;
 8000d96:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8000d9a:	e000      	b.n	8000d9e <UART_config+0x4a>
    case UART_DATABITS_8: sdatabits = USART_WORDLENGTH_8B; break;
    case UART_DATABITS_9: sdatabits = USART_WORDLENGTH_9B; break;
    default: return FALSE;
    }
    switch (stopbits) {
    case UART_STOPBITS_0_5: sstopbits = USART_STOPBITS_1; break;
 8000d9c:	2000      	movs	r0, #0
    case UART_STOPBITS_1: sstopbits = USART_STOPBITS_1; break;
    case UART_STOPBITS_1_5: sstopbits = USART_STOPBITS_1_5; break;
    case UART_STOPBITS_2: sstopbits = USART_STOPBITS_2; break;
    default: return FALSE;
    }
    switch (parity) {
 8000d9e:	2f01      	cmp	r7, #1
 8000da0:	d006      	beq.n	8000db0 <UART_config+0x5c>
 8000da2:	d308      	bcc.n	8000db6 <UART_config+0x62>
 8000da4:	2f02      	cmp	r7, #2
 8000da6:	f040 8103 	bne.w	8000fb0 <UART_config+0x25c>
    case UART_PARITY_NONE: sparity = USART_PARITY_NONE; break;
    case UART_PARITY_EVEN: sparity = USART_PARITY_EVEN; break;
    case UART_PARITY_ODD: sparity = USART_PARITY_ODD; break;
 8000daa:	f44f 67c0 	mov.w	r7, #1536	; 0x600
 8000dae:	e003      	b.n	8000db8 <UART_config+0x64>
    case UART_STOPBITS_2: sstopbits = USART_STOPBITS_2; break;
    default: return FALSE;
    }
    switch (parity) {
    case UART_PARITY_NONE: sparity = USART_PARITY_NONE; break;
    case UART_PARITY_EVEN: sparity = USART_PARITY_EVEN; break;
 8000db0:	f44f 6780 	mov.w	r7, #1024	; 0x400
 8000db4:	e000      	b.n	8000db8 <UART_config+0x64>
    case UART_STOPBITS_1_5: sstopbits = USART_STOPBITS_1_5; break;
    case UART_STOPBITS_2: sstopbits = USART_STOPBITS_2; break;
    default: return FALSE;
    }
    switch (parity) {
    case UART_PARITY_NONE: sparity = USART_PARITY_NONE; break;
 8000db6:	2700      	movs	r7, #0
 8000db8:	2300      	movs	r3, #0
    case UART_PARITY_EVEN: sparity = USART_PARITY_EVEN; break;
    case UART_PARITY_ODD: sparity = USART_PARITY_ODD; break;
    default: return FALSE;
    }
    switch (flowcontrol) {
 8000dba:	f1be 0f03 	cmp.w	lr, #3
 8000dbe:	f200 80f7 	bhi.w	8000fb0 <UART_config+0x25c>
 8000dc2:	e8df f00e 	tbb	[pc, lr]
 8000dc6:	050b      	.short	0x050b
 8000dc8:	0802      	.short	0x0802
    case UART_FLOWCONTROL_NONE: sflowcontrol = UART_HWCONTROL_NONE; break;
    case UART_FLOWCONTROL_CTS: sflowcontrol = UART_HWCONTROL_CTS; break;
 8000dca:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000dce:	e006      	b.n	8000dde <UART_config+0x8a>
    case UART_FLOWCONTROL_RTS: sflowcontrol = UART_HWCONTROL_RTS; break;
 8000dd0:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000dd4:	e003      	b.n	8000dde <UART_config+0x8a>
    case UART_FLOWCONTROL_RTS_CTS: sflowcontrol = UART_HWCONTROL_RTS_CTS; break;
 8000dd6:	f44f 7140 	mov.w	r1, #768	; 0x300
 8000dda:	e000      	b.n	8000dde <UART_config+0x8a>
    case UART_PARITY_EVEN: sparity = USART_PARITY_EVEN; break;
    case UART_PARITY_ODD: sparity = USART_PARITY_ODD; break;
    default: return FALSE;
    }
    switch (flowcontrol) {
    case UART_FLOWCONTROL_NONE: sflowcontrol = UART_HWCONTROL_NONE; break;
 8000ddc:	2100      	movs	r1, #0
    case UART_FLOWCONTROL_CTS: sflowcontrol = UART_HWCONTROL_CTS; break;
    case UART_FLOWCONTROL_RTS: sflowcontrol = UART_HWCONTROL_RTS; break;
    case UART_FLOWCONTROL_RTS_CTS: sflowcontrol = UART_HWCONTROL_RTS_CTS; break;
    default: return FALSE;
    }
    UART_HW(uart)->CR1 = 0;
 8000dde:	6023      	str	r3, [r4, #0]
    UART_HW(uart)->CR2 = 0;
 8000de0:	6063      	str	r3, [r4, #4]
    UART_HW(uart)->CR3 = 0;
 8000de2:	60a3      	str	r3, [r4, #8]
    /*-------------------------- USART CR1 Configuration -----------------------*/
    MODIFY_REG(UART_HW(uart)->CR1, USART_CR1_FIELDS,
 8000de4:	f8d4 e000 	ldr.w	lr, [r4]
 8000de8:	4b72      	ldr	r3, [pc, #456]	; (8000fb4 <UART_config+0x260>)
 8000dea:	ea0e 0303 	and.w	r3, lr, r3
 8000dee:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000df2:	f043 030c 	orr.w	r3, r3, #12
 8000df6:	431a      	orrs	r2, r3
 8000df8:	433a      	orrs	r2, r7
 8000dfa:	6022      	str	r2, [r4, #0]
        sdatabits | sparity | USART_CR1_OVER8 | USART_CR1_RE | USART_CR1_TE);

    /*---------------------------- USART CR2 Configuration ---------------------*/
    MODIFY_REG(UART_HW(uart)->CR2, USART_CR2_STOP,
 8000dfc:	6863      	ldr	r3, [r4, #4]
 8000dfe:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8000e02:	4318      	orrs	r0, r3
 8000e04:	6060      	str	r0, [r4, #4]
        sstopbits);

    UART_HW(uart)->CR2 &= ~USART_CR2_LINEN;
 8000e06:	6863      	ldr	r3, [r4, #4]
 8000e08:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8000e0c:	6063      	str	r3, [r4, #4]

    /*-------------------------- USART CR3 Configuration -----------------------*/
    MODIFY_REG(UART_HW(uart)->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT),
 8000e0e:	68a3      	ldr	r3, [r4, #8]
 8000e10:	f423 6330 	bic.w	r3, r3, #2816	; 0xb00
 8000e14:	4319      	orrs	r1, r3
        sflowcontrol);

    _UART_GETCLOCKSOURCE(UART_HW(uart), clocksource);
 8000e16:	4b68      	ldr	r3, [pc, #416]	; (8000fb8 <UART_config+0x264>)
        sstopbits);

    UART_HW(uart)->CR2 &= ~USART_CR2_LINEN;

    /*-------------------------- USART CR3 Configuration -----------------------*/
    MODIFY_REG(UART_HW(uart)->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT),
 8000e18:	60a1      	str	r1, [r4, #8]
        sflowcontrol);

    _UART_GETCLOCKSOURCE(UART_HW(uart), clocksource);
 8000e1a:	429c      	cmp	r4, r3
 8000e1c:	d107      	bne.n	8000e2e <UART_config+0xda>
 8000e1e:	f503 3394 	add.w	r3, r3, #75776	; 0x12800
 8000e22:	4a66      	ldr	r2, [pc, #408]	; (8000fbc <UART_config+0x268>)
 8000e24:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000e28:	f003 0303 	and.w	r3, r3, #3
 8000e2c:	e009      	b.n	8000e42 <UART_config+0xee>
 8000e2e:	4b64      	ldr	r3, [pc, #400]	; (8000fc0 <UART_config+0x26c>)
 8000e30:	429c      	cmp	r4, r3
 8000e32:	d111      	bne.n	8000e58 <UART_config+0x104>
 8000e34:	f503 33fa 	add.w	r3, r3, #128000	; 0x1f400
 8000e38:	4a62      	ldr	r2, [pc, #392]	; (8000fc4 <UART_config+0x270>)
 8000e3a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000e3e:	f003 030c 	and.w	r3, r3, #12
 8000e42:	5cd3      	ldrb	r3, [r2, r3]

    switch (clocksource)
 8000e44:	2b08      	cmp	r3, #8
 8000e46:	f200 80b3 	bhi.w	8000fb0 <UART_config+0x25c>
 8000e4a:	e8df f003 	tbb	[pc, r3]
 8000e4e:	7976      	.short	0x7976
 8000e50:	b17eb17c 	.word	0xb17eb17c
 8000e54:	b1b1      	.short	0xb1b1
 8000e56:	82          	.byte	0x82
 8000e57:	00          	.byte	0x00

    /*-------------------------- USART CR3 Configuration -----------------------*/
    MODIFY_REG(UART_HW(uart)->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT),
        sflowcontrol);

    _UART_GETCLOCKSOURCE(UART_HW(uart), clocksource);
 8000e58:	4b5b      	ldr	r3, [pc, #364]	; (8000fc8 <UART_config+0x274>)
 8000e5a:	429c      	cmp	r4, r3
 8000e5c:	d10c      	bne.n	8000e78 <UART_config+0x124>
 8000e5e:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
 8000e62:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000e66:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8000e6a:	2b10      	cmp	r3, #16
 8000e6c:	d06d      	beq.n	8000f4a <UART_config+0x1f6>
 8000e6e:	d95b      	bls.n	8000f28 <UART_config+0x1d4>
 8000e70:	2b20      	cmp	r3, #32
 8000e72:	d068      	beq.n	8000f46 <UART_config+0x1f2>
 8000e74:	2b30      	cmp	r3, #48	; 0x30
 8000e76:	e05e      	b.n	8000f36 <UART_config+0x1e2>
 8000e78:	4b54      	ldr	r3, [pc, #336]	; (8000fcc <UART_config+0x278>)
 8000e7a:	429c      	cmp	r4, r3
 8000e7c:	d10c      	bne.n	8000e98 <UART_config+0x144>
 8000e7e:	f503 33f6 	add.w	r3, r3, #125952	; 0x1ec00
 8000e82:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000e86:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8000e8a:	2b40      	cmp	r3, #64	; 0x40
 8000e8c:	d05d      	beq.n	8000f4a <UART_config+0x1f6>
 8000e8e:	d94b      	bls.n	8000f28 <UART_config+0x1d4>
 8000e90:	2b80      	cmp	r3, #128	; 0x80
 8000e92:	d058      	beq.n	8000f46 <UART_config+0x1f2>
 8000e94:	2bc0      	cmp	r3, #192	; 0xc0
 8000e96:	e04e      	b.n	8000f36 <UART_config+0x1e2>
 8000e98:	4b4d      	ldr	r3, [pc, #308]	; (8000fd0 <UART_config+0x27c>)
 8000e9a:	429c      	cmp	r4, r3
 8000e9c:	d10f      	bne.n	8000ebe <UART_config+0x16a>
 8000e9e:	f503 33f4 	add.w	r3, r3, #124928	; 0x1e800
 8000ea2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000ea6:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8000eaa:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8000eae:	d04c      	beq.n	8000f4a <UART_config+0x1f6>
 8000eb0:	d93a      	bls.n	8000f28 <UART_config+0x1d4>
 8000eb2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000eb6:	d046      	beq.n	8000f46 <UART_config+0x1f2>
 8000eb8:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8000ebc:	e03b      	b.n	8000f36 <UART_config+0x1e2>
 8000ebe:	4b45      	ldr	r3, [pc, #276]	; (8000fd4 <UART_config+0x280>)
 8000ec0:	429c      	cmp	r4, r3
 8000ec2:	d111      	bne.n	8000ee8 <UART_config+0x194>
 8000ec4:	f503 3392 	add.w	r3, r3, #74752	; 0x12400
 8000ec8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000ecc:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 8000ed0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8000ed4:	d039      	beq.n	8000f4a <UART_config+0x1f6>
 8000ed6:	d801      	bhi.n	8000edc <UART_config+0x188>
 8000ed8:	b393      	cbz	r3, 8000f40 <UART_config+0x1ec>
 8000eda:	e069      	b.n	8000fb0 <UART_config+0x25c>
 8000edc:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8000ee0:	d031      	beq.n	8000f46 <UART_config+0x1f2>
 8000ee2:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8000ee6:	e026      	b.n	8000f36 <UART_config+0x1e2>
 8000ee8:	4b3b      	ldr	r3, [pc, #236]	; (8000fd8 <UART_config+0x284>)
 8000eea:	429c      	cmp	r4, r3
 8000eec:	d10f      	bne.n	8000f0e <UART_config+0x1ba>
 8000eee:	f503 33e0 	add.w	r3, r3, #114688	; 0x1c000
 8000ef2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000ef6:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8000efa:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8000efe:	d024      	beq.n	8000f4a <UART_config+0x1f6>
 8000f00:	d912      	bls.n	8000f28 <UART_config+0x1d4>
 8000f02:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8000f06:	d01e      	beq.n	8000f46 <UART_config+0x1f2>
 8000f08:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8000f0c:	e013      	b.n	8000f36 <UART_config+0x1e2>
 8000f0e:	4b33      	ldr	r3, [pc, #204]	; (8000fdc <UART_config+0x288>)
 8000f10:	429c      	cmp	r4, r3
 8000f12:	d14d      	bne.n	8000fb0 <UART_config+0x25c>
 8000f14:	f503 33de 	add.w	r3, r3, #113664	; 0x1bc00
 8000f18:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000f1c:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8000f20:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8000f24:	d011      	beq.n	8000f4a <UART_config+0x1f6>
 8000f26:	d801      	bhi.n	8000f2c <UART_config+0x1d8>
 8000f28:	b13b      	cbz	r3, 8000f3a <UART_config+0x1e6>
 8000f2a:	e041      	b.n	8000fb0 <UART_config+0x25c>
 8000f2c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8000f30:	d009      	beq.n	8000f46 <UART_config+0x1f2>
 8000f32:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 8000f36:	d00c      	beq.n	8000f52 <UART_config+0x1fe>
 8000f38:	e03a      	b.n	8000fb0 <UART_config+0x25c>

    switch (clocksource)
    {
    case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(_UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), baud));
 8000f3a:	f001 f899 	bl	8002070 <HAL_RCC_GetPCLK1Freq>
 8000f3e:	e006      	b.n	8000f4e <UART_config+0x1fa>
      break;
    case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(_UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), baud));
 8000f40:	f001 f8ac 	bl	800209c <HAL_RCC_GetPCLK2Freq>
 8000f44:	e003      	b.n	8000f4e <UART_config+0x1fa>
      break;
    case UART_CLOCKSOURCE_HSI:
        usartdiv = (uint16_t)(_UART_DIV_SAMPLING8(HSI_VALUE, baud));
 8000f46:	4826      	ldr	r0, [pc, #152]	; (8000fe0 <UART_config+0x28c>)
 8000f48:	e005      	b.n	8000f56 <UART_config+0x202>
      break;
    case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(_UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), baud));
 8000f4a:	f001 f839 	bl	8001fc0 <HAL_RCC_GetSysClockFreq>
 8000f4e:	0040      	lsls	r0, r0, #1
 8000f50:	e001      	b.n	8000f56 <UART_config+0x202>
      break;
    case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(_UART_DIV_SAMPLING8(LSE_VALUE, baud));
 8000f52:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8000f56:	fbb0 f1f6 	udiv	r1, r0, r6
 8000f5a:	b289      	uxth	r1, r1
    default:
        return FALSE;
      break;
    }

    u32_t brrtemp = usartdiv & 0xFFF0;
 8000f5c:	f021 030f 	bic.w	r3, r1, #15
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
 8000f60:	f3c1 0142 	ubfx	r1, r1, #1, #3
 8000f64:	4319      	orrs	r1, r3
    UART_HW(uart)->BRR = brrtemp;
 8000f66:	682b      	ldr	r3, [r5, #0]
 8000f68:	60d9      	str	r1, [r3, #12]
    // enable usart interrupts
    _UART_ENABLE_IT(UART_HW(uart), USART_IT_TC);
 8000f6a:	681a      	ldr	r2, [r3, #0]
 8000f6c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000f70:	601a      	str	r2, [r3, #0]
    _UART_ENABLE_IT(UART_HW(uart), USART_IT_TXE);
 8000f72:	681a      	ldr	r2, [r3, #0]
 8000f74:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000f78:	601a      	str	r2, [r3, #0]
    _UART_ENABLE_IT(UART_HW(uart), USART_IT_RXNE);
 8000f7a:	681a      	ldr	r2, [r3, #0]
 8000f7c:	f042 0220 	orr.w	r2, r2, #32
 8000f80:	601a      	str	r2, [r3, #0]
    UART_HW(uart)->CR1 |= USART_CR1_UE; // enable uart
 8000f82:	681a      	ldr	r2, [r3, #0]
 8000f84:	f042 0201 	orr.w	r2, r2, #1
 8000f88:	601a      	str	r2, [r3, #0]
 8000f8a:	e00f      	b.n	8000fac <UART_config+0x258>
  } else {
    // disable usart interrupts
    _UART_DISABLE_IT(UART_HW(uart), USART_IT_TC);
 8000f8c:	6823      	ldr	r3, [r4, #0]
 8000f8e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000f92:	6023      	str	r3, [r4, #0]
    _UART_DISABLE_IT(UART_HW(uart), USART_IT_TXE);
 8000f94:	6823      	ldr	r3, [r4, #0]
 8000f96:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8000f9a:	6023      	str	r3, [r4, #0]
    _UART_DISABLE_IT(UART_HW(uart), USART_IT_RXNE);
 8000f9c:	6823      	ldr	r3, [r4, #0]
 8000f9e:	f023 0320 	bic.w	r3, r3, #32
 8000fa2:	6023      	str	r3, [r4, #0]
    UART_HW(uart)->CR1 &= ~USART_CR1_UE; // disable uart
 8000fa4:	6823      	ldr	r3, [r4, #0]
 8000fa6:	f023 0301 	bic.w	r3, r3, #1
 8000faa:	6023      	str	r3, [r4, #0]
  }
  return TRUE;
 8000fac:	2001      	movs	r0, #1
 8000fae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(_UART_DIV_SAMPLING8(LSE_VALUE, baud));
      break;
      case UART_CLOCKSOURCE_UNDEFINED:
    default:
        return FALSE;
 8000fb0:	2000      	movs	r0, #0
    _UART_DISABLE_IT(UART_HW(uart), USART_IT_TXE);
    _UART_DISABLE_IT(UART_HW(uart), USART_IT_RXNE);
    UART_HW(uart)->CR1 &= ~USART_CR1_UE; // disable uart
  }
  return TRUE;
}
 8000fb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000fb4:	efff69f3 	.word	0xefff69f3
 8000fb8:	40011000 	.word	0x40011000
 8000fbc:	08002332 	.word	0x08002332
 8000fc0:	40004400 	.word	0x40004400
 8000fc4:	08002336 	.word	0x08002336
 8000fc8:	40004800 	.word	0x40004800
 8000fcc:	40004c00 	.word	0x40004c00
 8000fd0:	40005000 	.word	0x40005000
 8000fd4:	40011400 	.word	0x40011400
 8000fd8:	40007800 	.word	0x40007800
 8000fdc:	40007c00 	.word	0x40007c00
 8000fe0:	01e84800 	.word	0x01e84800

08000fe4 <UART_init>:


void UART_init() {
 8000fe4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  memset(__uart_vec, 0, sizeof(__uart_vec));
 8000fe6:	4c0d      	ldr	r4, [pc, #52]	; (800101c <UART_init+0x38>)
 8000fe8:	f44f 6283 	mov.w	r2, #1048	; 0x418
 8000fec:	2100      	movs	r1, #0
 8000fee:	4620      	mov	r0, r4
 8000ff0:	f7ff f8ea 	bl	80001c8 <memset>
  int uc = 0;

#ifdef CONFIG_UART3
  _UART(uc++)->hw = USART3;
 8000ff4:	4b0a      	ldr	r3, [pc, #40]	; (8001020 <UART_init+0x3c>)
 8000ff6:	6023      	str	r3, [r4, #0]
  UART_config(_UART(uc-1), 115200, UART_DATABITS_8, UART_STOPBITS_1,
 8000ff8:	2200      	movs	r2, #0
 8000ffa:	2301      	movs	r3, #1
 8000ffc:	9302      	str	r3, [sp, #8]
 8000ffe:	9201      	str	r2, [sp, #4]
 8001000:	9200      	str	r2, [sp, #0]
 8001002:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
 8001006:	4620      	mov	r0, r4
 8001008:	f7ff fea4 	bl	8000d54 <UART_config>
      UART_PARITY_NONE, UART_FLOWCONTROL_NONE, TRUE);
  UART_SET_TX_IRQ_OFF(_UART(uc-1));
 800100c:	6822      	ldr	r2, [r4, #0]
 800100e:	6813      	ldr	r3, [r2, #0]
 8001010:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001014:	6013      	str	r3, [r2, #0]
  _UART(uc++)->hw = USART6;
  UART_config(_UART(uc-1), 115200, UART_DATABITS_8, UART_STOPBITS_1,
      UART_PARITY_NONE, UART_FLOWCONTROL_NONE, TRUE);
  UART_SET_TX_IRQ_OFF(_UART(uc-1));
#endif
}
 8001016:	b004      	add	sp, #16
 8001018:	bd10      	pop	{r4, pc}
 800101a:	bf00      	nop
 800101c:	20003eec 	.word	0x20003eec
 8001020:	40004800 	.word	0x40004800

08001024 <USART3_IRQHandler>:

void USART3_IRQHandler(void) {
  UART_irq(_UART(0));
 8001024:	4801      	ldr	r0, [pc, #4]	; (800102c <USART3_IRQHandler+0x8>)
 8001026:	f7ff bd3c 	b.w	8000aa2 <UART_irq>
 800102a:	bf00      	nop
 800102c:	20003eec 	.word	0x20003eec

08001030 <Yin_difference>:
 * @param buffer Buffer of samples to process. 
 *
 * This is the Yin algorithms tweak on autocorellation. Read http://audition.ens.fr/adc/pdf/2002_JASA_YIN.pdf
 * for more details on what is in here and why it's done this way.
 */
void Yin_difference(Yin *yin, int16_t* buffer){
 8001030:	b5f0      	push	{r4, r5, r6, r7, lr}
	int16_t i;
	int16_t tau;
	float delta;

	/* Calculate the difference for difference shift values (tau) for the half of the samples */
	for(tau = 0 ; tau < yin->halfBufferSize; tau++){
 8001032:	f9b0 6002 	ldrsh.w	r6, [r0, #2]
 8001036:	2200      	movs	r2, #0
 8001038:	b213      	sxth	r3, r2
 800103a:	429e      	cmp	r6, r3
 800103c:	dd1a      	ble.n	8001074 <Yin_difference+0x44>
 800103e:	0097      	lsls	r7, r2, #2
 8001040:	2500      	movs	r5, #0

		/* Take the difference of the signal with a shifted version of itself, then square it.
		 * (This is the Yin algorithm's tweak on autocorellation) */ 
		for(i = 0; i < yin->halfBufferSize; i++){
 8001042:	b22c      	sxth	r4, r5
 8001044:	42b4      	cmp	r4, r6
 8001046:	da13      	bge.n	8001070 <Yin_difference+0x40>
			delta = buffer[i] - buffer[i + tau];
 8001048:	f931 3014 	ldrsh.w	r3, [r1, r4, lsl #1]
 800104c:	4414      	add	r4, r2
 800104e:	3501      	adds	r5, #1
 8001050:	f931 4014 	ldrsh.w	r4, [r1, r4, lsl #1]
 8001054:	1b1b      	subs	r3, r3, r4
 8001056:	ee07 3a90 	vmov	s15, r3
			yin->yinBuffer[tau] += delta * delta;
 800105a:	6843      	ldr	r3, [r0, #4]
 800105c:	443b      	add	r3, r7
 800105e:	ed93 7a00 	vldr	s14, [r3]
	for(tau = 0 ; tau < yin->halfBufferSize; tau++){

		/* Take the difference of the signal with a shifted version of itself, then square it.
		 * (This is the Yin algorithm's tweak on autocorellation) */ 
		for(i = 0; i < yin->halfBufferSize; i++){
			delta = buffer[i] - buffer[i + tau];
 8001062:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			yin->yinBuffer[tau] += delta * delta;
 8001066:	eea7 7aa7 	vfma.f32	s14, s15, s15
 800106a:	ed83 7a00 	vstr	s14, [r3]
 800106e:	e7e8      	b.n	8001042 <Yin_difference+0x12>
 8001070:	3201      	adds	r2, #1
 8001072:	e7e1      	b.n	8001038 <Yin_difference+0x8>
 8001074:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08001078 <Yin_cumulativeMeanNormalizedDifference>:
 * produced the smallest difference
 */
void Yin_cumulativeMeanNormalizedDifference(Yin *yin){
	int16_t tau;
	float runningSum = 0;
	yin->yinBuffer[0] = 1;
 8001078:	6841      	ldr	r1, [r0, #4]
 * This goes through the Yin autocorellation values and finds out roughly where shift is which 
 * produced the smallest difference
 */
void Yin_cumulativeMeanNormalizedDifference(Yin *yin){
	int16_t tau;
	float runningSum = 0;
 800107a:	ed9f 7a10 	vldr	s14, [pc, #64]	; 80010bc <Yin_cumulativeMeanNormalizedDifference+0x44>
 * @param yin #Yin structure with information about the signal
 *
 * This goes through the Yin autocorellation values and finds out roughly where shift is which 
 * produced the smallest difference
 */
void Yin_cumulativeMeanNormalizedDifference(Yin *yin){
 800107e:	b510      	push	{r4, lr}
	int16_t tau;
	float runningSum = 0;
	yin->yinBuffer[0] = 1;
 8001080:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000

	/* Sum all the values in the autocorellation buffer and nomalise the result, replacing
	 * the value in the autocorellation buffer with a cumulative mean of the normalised difference */
	for (tau = 1; tau < yin->halfBufferSize; tau++) {
 8001084:	f9b0 4002 	ldrsh.w	r4, [r0, #2]
 * produced the smallest difference
 */
void Yin_cumulativeMeanNormalizedDifference(Yin *yin){
	int16_t tau;
	float runningSum = 0;
	yin->yinBuffer[0] = 1;
 8001088:	600b      	str	r3, [r1, #0]

	/* Sum all the values in the autocorellation buffer and nomalise the result, replacing
	 * the value in the autocorellation buffer with a cumulative mean of the normalised difference */
	for (tau = 1; tau < yin->halfBufferSize; tau++) {
 800108a:	2201      	movs	r2, #1
 800108c:	b213      	sxth	r3, r2
 800108e:	42a3      	cmp	r3, r4
 8001090:	da12      	bge.n	80010b8 <Yin_cumulativeMeanNormalizedDifference+0x40>
		runningSum += yin->yinBuffer[tau];
 8001092:	eb01 0083 	add.w	r0, r1, r3, lsl #2
 8001096:	ed90 6a00 	vldr	s12, [r0]
		yin->yinBuffer[tau] *= tau / runningSum;
 800109a:	ee07 3a90 	vmov	s15, r3
	yin->yinBuffer[0] = 1;

	/* Sum all the values in the autocorellation buffer and nomalise the result, replacing
	 * the value in the autocorellation buffer with a cumulative mean of the normalised difference */
	for (tau = 1; tau < yin->halfBufferSize; tau++) {
		runningSum += yin->yinBuffer[tau];
 800109e:	ee37 7a06 	vadd.f32	s14, s14, s12
		yin->yinBuffer[tau] *= tau / runningSum;
 80010a2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80010a6:	3201      	adds	r2, #1
 80010a8:	eec7 6a87 	vdiv.f32	s13, s15, s14
 80010ac:	b292      	uxth	r2, r2
 80010ae:	ee66 7a86 	vmul.f32	s15, s13, s12
 80010b2:	edc0 7a00 	vstr	s15, [r0]
 80010b6:	e7e9      	b.n	800108c <Yin_cumulativeMeanNormalizedDifference+0x14>
	}
}
 80010b8:	bd10      	pop	{r4, pc}
 80010ba:	bf00      	nop
 80010bc:	00000000 	.word	0x00000000

080010c0 <Yin_absoluteThreshold>:

/**
 * Step 3: Search through the normalised cumulative mean array and find values that are over the threshold
 * @return Shift (tau) which caused the best approximate autocorellation. -1 if no suitable value is found over the threshold.
 */
int16_t Yin_absoluteThreshold(Yin *yin){
 80010c0:	b530      	push	{r4, r5, lr}
	int16_t tau;

	/* Search through the array of cumulative mean values, and look for ones that are over the threshold 
	 * The first two positions in yinBuffer are always so start at the third (index 2) */
	for (tau = 2; tau < yin->halfBufferSize ; tau++) {
 80010c2:	f9b0 4002 	ldrsh.w	r4, [r0, #2]
 80010c6:	2108      	movs	r1, #8
 80010c8:	2302      	movs	r3, #2
 80010ca:	b21a      	sxth	r2, r3
 80010cc:	42a2      	cmp	r2, r4
 80010ce:	da2c      	bge.n	800112a <Yin_absoluteThreshold+0x6a>
		if (yin->yinBuffer[tau] < yin->threshold) {
 80010d0:	6842      	ldr	r2, [r0, #4]
 80010d2:	edd0 7a03 	vldr	s15, [r0, #12]
 80010d6:	1855      	adds	r5, r2, r1
 80010d8:	ed95 7a00 	vldr	s14, [r5]
 80010dc:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80010e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80010e4:	f101 0104 	add.w	r1, r1, #4
 80010e8:	d51c      	bpl.n	8001124 <Yin_absoluteThreshold+0x64>
			while (tau + 1 < yin->halfBufferSize && yin->yinBuffer[tau + 1] < yin->yinBuffer[tau]) {
 80010ea:	b21d      	sxth	r5, r3
 80010ec:	1c69      	adds	r1, r5, #1
 80010ee:	42a1      	cmp	r1, r4
 80010f0:	db0a      	blt.n	8001108 <Yin_absoluteThreshold+0x48>
			 * proportion of aperiodic power tolerated
			 * within a periodic signal.
			 *
			 * Since we want the periodicity and and not aperiodicity:
			 * periodicity = 1 - aperiodicity */
			yin->probability = 1 - yin->yinBuffer[tau];
 80010f2:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 80010f6:	ed92 7a00 	vldr	s14, [r2]
 80010fa:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 80010fe:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8001102:	edc0 7a02 	vstr	s15, [r0, #8]
			break;
 8001106:	e010      	b.n	800112a <Yin_absoluteThreshold+0x6a>

	/* Search through the array of cumulative mean values, and look for ones that are over the threshold 
	 * The first two positions in yinBuffer are always so start at the third (index 2) */
	for (tau = 2; tau < yin->halfBufferSize ; tau++) {
		if (yin->yinBuffer[tau] < yin->threshold) {
			while (tau + 1 < yin->halfBufferSize && yin->yinBuffer[tau + 1] < yin->yinBuffer[tau]) {
 8001108:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 800110c:	ed91 7a00 	vldr	s14, [r1]
 8001110:	ed51 7a01 	vldr	s15, [r1, #-4]
 8001114:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8001118:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800111c:	d5e9      	bpl.n	80010f2 <Yin_absoluteThreshold+0x32>
 800111e:	3301      	adds	r3, #1
 8001120:	b29b      	uxth	r3, r3
 8001122:	e7e2      	b.n	80010ea <Yin_absoluteThreshold+0x2a>
 8001124:	3301      	adds	r3, #1
 8001126:	b29b      	uxth	r3, r3
 8001128:	e7cf      	b.n	80010ca <Yin_absoluteThreshold+0xa>
			break;
		}
	}

	/* if no pitch found, tau => -1 */
	if (tau == yin->halfBufferSize || yin->yinBuffer[tau] >= yin->threshold) {
 800112a:	b219      	sxth	r1, r3
 800112c:	42a1      	cmp	r1, r4
 800112e:	d00b      	beq.n	8001148 <Yin_absoluteThreshold+0x88>
 8001130:	6842      	ldr	r2, [r0, #4]
 8001132:	edd0 7a03 	vldr	s15, [r0, #12]
 8001136:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 800113a:	ed92 7a00 	vldr	s14, [r2]
 800113e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8001142:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001146:	db03      	blt.n	8001150 <Yin_absoluteThreshold+0x90>
		tau = -1;
		yin->probability = 0;
 8001148:	2300      	movs	r3, #0
 800114a:	6083      	str	r3, [r0, #8]
		}
	}

	/* if no pitch found, tau => -1 */
	if (tau == yin->halfBufferSize || yin->yinBuffer[tau] >= yin->threshold) {
		tau = -1;
 800114c:	f64f 73ff 	movw	r3, #65535	; 0xffff
		yin->probability = 0;
	}

	return tau;
}
 8001150:	b218      	sxth	r0, r3
 8001152:	bd30      	pop	{r4, r5, pc}

08001154 <Yin_parabolicInterpolation>:
	float betterTau;
	int16_t x0;
	int16_t x2;
	
	/* Calculate the first polynomial coeffcient based on the current estimate of tau */
	if (tauEstimate < 1) {
 8001154:	2900      	cmp	r1, #0
	else {
		x0 = tauEstimate - 1;
	}

	/* Calculate the second polynomial coeffcient based on the current estimate of tau */
	if (tauEstimate + 1 < yin->halfBufferSize) {
 8001156:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
	/* Calculate the first polynomial coeffcient based on the current estimate of tau */
	if (tauEstimate < 1) {
		x0 = tauEstimate;
	} 
	else {
		x0 = tauEstimate - 1;
 800115a:	bfc8      	it	gt
 800115c:	f101 33ff 	addgt.w	r3, r1, #4294967295	; 0xffffffff
 *
 * The 'best' shift value for autocorellation is most likely not an interger shift of the signal.
 * As we only autocorellated using integer shifts we should check that there isn't a better fractional 
 * shift value.
 */
float Yin_parabolicInterpolation(Yin *yin, int16_t tauEstimate) {
 8001160:	b510      	push	{r4, lr}
	else {
		x0 = tauEstimate - 1;
	}

	/* Calculate the second polynomial coeffcient based on the current estimate of tau */
	if (tauEstimate + 1 < yin->halfBufferSize) {
 8001162:	f101 0401 	add.w	r4, r1, #1
	/* Calculate the first polynomial coeffcient based on the current estimate of tau */
	if (tauEstimate < 1) {
		x0 = tauEstimate;
	} 
	else {
		x0 = tauEstimate - 1;
 8001166:	bfcc      	ite	gt
 8001168:	b21b      	sxthgt	r3, r3
 800116a:	460b      	movle	r3, r1
	}

	/* Calculate the second polynomial coeffcient based on the current estimate of tau */
	if (tauEstimate + 1 < yin->halfBufferSize) {
 800116c:	4294      	cmp	r4, r2
 800116e:	6842      	ldr	r2, [r0, #4]
 8001170:	ea4f 0083 	mov.w	r0, r3, lsl #2
 8001174:	da44      	bge.n	8001200 <Yin_parabolicInterpolation+0xac>
	else {
		x2 = tauEstimate;
	}

	/* Algorithm to parabolically interpolate the shift value tau to find a better estimate */
	if (x0 == tauEstimate) {
 8001176:	428b      	cmp	r3, r1
		x0 = tauEstimate - 1;
	}

	/* Calculate the second polynomial coeffcient based on the current estimate of tau */
	if (tauEstimate + 1 < yin->halfBufferSize) {
		x2 = tauEstimate + 1;
 8001178:	b224      	sxth	r4, r4
	else {
		x2 = tauEstimate;
	}

	/* Algorithm to parabolically interpolate the shift value tau to find a better estimate */
	if (x0 == tauEstimate) {
 800117a:	d10d      	bne.n	8001198 <Yin_parabolicInterpolation+0x44>
		x0 = tauEstimate - 1;
	}

	/* Calculate the second polynomial coeffcient based on the current estimate of tau */
	if (tauEstimate + 1 < yin->halfBufferSize) {
		x2 = tauEstimate + 1;
 800117c:	4621      	mov	r1, r4
		x2 = tauEstimate;
	}

	/* Algorithm to parabolically interpolate the shift value tau to find a better estimate */
	if (x0 == tauEstimate) {
		if (yin->yinBuffer[tauEstimate] <= yin->yinBuffer[x2]) {
 800117e:	4410      	add	r0, r2
 8001180:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8001184:	ed90 7a00 	vldr	s14, [r0]
 8001188:	edd2 7a00 	vldr	s15, [r2]
 800118c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8001190:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001194:	d80e      	bhi.n	80011b4 <Yin_parabolicInterpolation+0x60>
 8001196:	e010      	b.n	80011ba <Yin_parabolicInterpolation+0x66>
		} 
		else {
			betterTau = x2;
		}
	} 
	else if (x2 == tauEstimate) {
 8001198:	42a1      	cmp	r1, r4
 800119a:	d113      	bne.n	80011c4 <Yin_parabolicInterpolation+0x70>
		if (yin->yinBuffer[tauEstimate] <= yin->yinBuffer[x0]) {
 800119c:	eb02 0481 	add.w	r4, r2, r1, lsl #2
 80011a0:	4402      	add	r2, r0
 80011a2:	ed94 7a00 	vldr	s14, [r4]
 80011a6:	edd2 7a00 	vldr	s15, [r2]
 80011aa:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80011ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80011b2:	d802      	bhi.n	80011ba <Yin_parabolicInterpolation+0x66>
			betterTau = tauEstimate;
 80011b4:	ee07 1a90 	vmov	s15, r1
 80011b8:	e001      	b.n	80011be <Yin_parabolicInterpolation+0x6a>
		} 
		else {
			betterTau = x0;
 80011ba:	ee07 3a90 	vmov	s15, r3
 80011be:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 80011c2:	bd10      	pop	{r4, pc}
		}
	} 
	else {
		float s0, s1, s2;
		s0 = yin->yinBuffer[x0];
 80011c4:	4410      	add	r0, r2
		s1 = yin->yinBuffer[tauEstimate];
		s2 = yin->yinBuffer[x2];
 80011c6:	eb02 0484 	add.w	r4, r2, r4, lsl #2
		}
	} 
	else {
		float s0, s1, s2;
		s0 = yin->yinBuffer[x0];
		s1 = yin->yinBuffer[tauEstimate];
 80011ca:	eb02 0281 	add.w	r2, r2, r1, lsl #2
			betterTau = x0;
		}
	} 
	else {
		float s0, s1, s2;
		s0 = yin->yinBuffer[x0];
 80011ce:	ed90 7a00 	vldr	s14, [r0]
		s1 = yin->yinBuffer[tauEstimate];
		s2 = yin->yinBuffer[x2];
 80011d2:	edd4 7a00 	vldr	s15, [r4]
		// fixed AUBIO implementation, thanks to Karl Helgason:
		// (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1
		betterTau = tauEstimate + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
 80011d6:	edd2 5a00 	vldr	s11, [r2]
 80011da:	eeb0 6a00 	vmov.f32	s12, #0
 80011de:	ee77 6ac7 	vsub.f32	s13, s15, s14
 80011e2:	eed5 7a86 	vfnms.f32	s15, s11, s12
 80011e6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80011ea:	ee37 7aa7 	vadd.f32	s14, s15, s15
 80011ee:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80011f2:	ee07 1a10 	vmov	s14, r1
 80011f6:	eeb8 0ac7 	vcvt.f32.s32	s0, s14
 80011fa:	ee37 0a80 	vadd.f32	s0, s15, s0
	}


	return betterTau;
 80011fe:	bd10      	pop	{r4, pc}
	else {
		x2 = tauEstimate;
	}

	/* Algorithm to parabolically interpolate the shift value tau to find a better estimate */
	if (x0 == tauEstimate) {
 8001200:	428b      	cmp	r3, r1
 8001202:	d0bc      	beq.n	800117e <Yin_parabolicInterpolation+0x2a>
 8001204:	e7ca      	b.n	800119c <Yin_parabolicInterpolation+0x48>

08001206 <Yin_init>:
 * @param yin        Yin pitch detection object to initialise
 * @param bufferSize Length of the audio buffer to analyse
 * @param threshold  Allowed uncertainty (e.g 0.05 will return a pitch with ~95% probability)
 * @param work       work buffer, bufferSize/2 worth of floats
 */
void Yin_init(Yin *yin, int16_t bufferSize, float threshold, float *work){
 8001206:	b510      	push	{r4, lr}
	/* Initialise the fields of the Yin structure passed in */
	yin->bufferSize = bufferSize;
	yin->halfBufferSize = bufferSize / 2;
 8001208:	2302      	movs	r3, #2
 * @param threshold  Allowed uncertainty (e.g 0.05 will return a pitch with ~95% probability)
 * @param work       work buffer, bufferSize/2 worth of floats
 */
void Yin_init(Yin *yin, int16_t bufferSize, float threshold, float *work){
	/* Initialise the fields of the Yin structure passed in */
	yin->bufferSize = bufferSize;
 800120a:	8001      	strh	r1, [r0, #0]
	yin->halfBufferSize = bufferSize / 2;
 800120c:	fb91 f1f3 	sdiv	r1, r1, r3
	yin->probability = 0.0;
 8001210:	2300      	movs	r3, #0
 * @param work       work buffer, bufferSize/2 worth of floats
 */
void Yin_init(Yin *yin, int16_t bufferSize, float threshold, float *work){
	/* Initialise the fields of the Yin structure passed in */
	yin->bufferSize = bufferSize;
	yin->halfBufferSize = bufferSize / 2;
 8001212:	b289      	uxth	r1, r1
 8001214:	8041      	strh	r1, [r0, #2]
	yin->probability = 0.0;
 8001216:	6083      	str	r3, [r0, #8]
	yin->threshold = threshold;
 8001218:	ed80 0a03 	vstr	s0, [r0, #12]

	/* Allocate the autocorellation buffer and initialise it to zero */
	yin->yinBuffer = work; //(float *) malloc(sizeof(float)* yin->halfBufferSize);
 800121c:	6042      	str	r2, [r0, #4]

	int16_t i;
	for(i = 0; i < yin->halfBufferSize; i++){
 800121e:	b209      	sxth	r1, r1
 8001220:	2000      	movs	r0, #0
 8001222:	b204      	sxth	r4, r0
 8001224:	42a1      	cmp	r1, r4
 8001226:	dd03      	ble.n	8001230 <Yin_init+0x2a>
		yin->yinBuffer[i] = 0;
 8001228:	f842 3b04 	str.w	r3, [r2], #4
 800122c:	3001      	adds	r0, #1
 800122e:	e7f8      	b.n	8001222 <Yin_init+0x1c>
	}
}
 8001230:	bd10      	pop	{r4, pc}
	...

08001234 <Yin_getPitch>:
 * Runs the Yin pitch detection algortihm
 * @param  yin    Initialised Yin object
 * @param  buffer Buffer of samples to analyse
 * @return        Fundamental frequency of the signal in Hz. Returns -1 if pitch can't be found
 */
float Yin_getPitch(Yin *yin, int16_t* buffer){
 8001234:	b510      	push	{r4, lr}
 8001236:	4604      	mov	r4, r0
	int16_t tauEstimate = -1;
	float pitchInHertz = -1;
	
	/* Step 1: Calculates the squared difference of the signal with a shifted version of itself. */
	Yin_difference(yin, buffer);
 8001238:	f7ff fefa 	bl	8001030 <Yin_difference>
	
	/* Step 2: Calculate the cumulative mean on the normalised difference calculated in step 1 */
	Yin_cumulativeMeanNormalizedDifference(yin);
 800123c:	f7ff ff1c 	bl	8001078 <Yin_cumulativeMeanNormalizedDifference>
	
	/* Step 3: Search through the normalised cumulative mean array and find values that are over the threshold */
	tauEstimate = Yin_absoluteThreshold(yin);
 8001240:	4620      	mov	r0, r4
 8001242:	f7ff ff3d 	bl	80010c0 <Yin_absoluteThreshold>
	
	/* Step 5: Interpolate the shift value (tau) to improve the pitch estimate. */
	if(tauEstimate != -1){
 8001246:	1c43      	adds	r3, r0, #1
	
	/* Step 2: Calculate the cumulative mean on the normalised difference calculated in step 1 */
	Yin_cumulativeMeanNormalizedDifference(yin);
	
	/* Step 3: Search through the normalised cumulative mean array and find values that are over the threshold */
	tauEstimate = Yin_absoluteThreshold(yin);
 8001248:	4601      	mov	r1, r0
	
	/* Step 5: Interpolate the shift value (tau) to improve the pitch estimate. */
	if(tauEstimate != -1){
 800124a:	d007      	beq.n	800125c <Yin_getPitch+0x28>
		pitchInHertz = YIN_SAMPLING_RATE / Yin_parabolicInterpolation(yin, tauEstimate);
 800124c:	4620      	mov	r0, r4
 800124e:	f7ff ff81 	bl	8001154 <Yin_parabolicInterpolation>
 8001252:	eddf 7a04 	vldr	s15, [pc, #16]	; 8001264 <Yin_getPitch+0x30>
 8001256:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800125a:	bd10      	pop	{r4, pc}
 * @param  buffer Buffer of samples to analyse
 * @return        Fundamental frequency of the signal in Hz. Returns -1 if pitch can't be found
 */
float Yin_getPitch(Yin *yin, int16_t* buffer){
	int16_t tauEstimate = -1;
	float pitchInHertz = -1;
 800125c:	eebf 0a00 	vmov.f32	s0, #240	; 0xf0
	if(tauEstimate != -1){
		pitchInHertz = YIN_SAMPLING_RATE / Yin_parabolicInterpolation(yin, tauEstimate);
	}
	
	return pitchInHertz;
}
 8001260:	bd10      	pop	{r4, pc}
 8001262:	bf00      	nop
 8001264:	47371b00 	.word	0x47371b00

08001268 <Yin_getProbability>:
 * @param  yin Yin object that has been run over a buffer
 * @return     Returns the certainty of the note found as a decimal (i.e 0.3 is 30%)
 */
float Yin_getProbability(Yin *yin){
	return yin->probability;
}
 8001268:	ed90 0a02 	vldr	s0, [r0, #8]
 800126c:	4770      	bx	lr

0800126e <HAL_MspInit>:
 800126e:	4770      	bx	lr

08001270 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001270:	b510      	push	{r4, lr}
 8001272:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8001274:	f000 fee2 	bl	800203c <HAL_RCC_GetHCLKFreq>
 8001278:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800127c:	fbb0 f0f3 	udiv	r0, r0, r3
 8001280:	f000 fa8c 	bl	800179c <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 8001284:	2200      	movs	r2, #0
 8001286:	4621      	mov	r1, r4
 8001288:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800128c:	f000 fa46 	bl	800171c <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8001290:	2000      	movs	r0, #0
 8001292:	bd10      	pop	{r4, pc}

08001294 <HAL_Init>:
  */
HAL_StatusTypeDef HAL_Init(void)
{
  /* Configure Flash prefetch and Instruction cache through ART accelerator */ 
#if (ART_ACCLERATOR_ENABLE != 0)
   __HAL_FLASH_ART_ENABLE();
 8001294:	4a07      	ldr	r2, [pc, #28]	; (80012b4 <HAL_Init+0x20>)
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001296:	b508      	push	{r3, lr}
  /* Configure Flash prefetch and Instruction cache through ART accelerator */ 
#if (ART_ACCLERATOR_ENABLE != 0)
   __HAL_FLASH_ART_ENABLE();
 8001298:	6813      	ldr	r3, [r2, #0]
 800129a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800129e:	6013      	str	r3, [r2, #0]
#endif /* ART_ACCLERATOR_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80012a0:	2003      	movs	r0, #3
 80012a2:	f000 fa29 	bl	80016f8 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80012a6:	200f      	movs	r0, #15
 80012a8:	f7ff ffe2 	bl	8001270 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 80012ac:	f7ff ffdf 	bl	800126e <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 80012b0:	2000      	movs	r0, #0
 80012b2:	bd08      	pop	{r3, pc}
 80012b4:	40023c00 	.word	0x40023c00

080012b8 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 80012b8:	4a02      	ldr	r2, [pc, #8]	; (80012c4 <HAL_IncTick+0xc>)
 80012ba:	6813      	ldr	r3, [r2, #0]
 80012bc:	3301      	adds	r3, #1
 80012be:	6013      	str	r3, [r2, #0]
 80012c0:	4770      	bx	lr
 80012c2:	bf00      	nop
 80012c4:	20003e94 	.word	0x20003e94

080012c8 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80012c8:	4b01      	ldr	r3, [pc, #4]	; (80012d0 <HAL_GetTick+0x8>)
 80012ca:	6818      	ldr	r0, [r3, #0]
}
 80012cc:	4770      	bx	lr
 80012ce:	bf00      	nop
 80012d0:	20003e94 	.word	0x20003e94

080012d4 <HAL_ADC_MspInit>:
 80012d4:	4770      	bx	lr
	...

080012d8 <HAL_ADC_Init>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 80012d8:	b510      	push	{r4, lr}
  /* Check ADC handle */
  if(hadc == NULL)
 80012da:	4604      	mov	r4, r0
 80012dc:	2800      	cmp	r0, #0
 80012de:	f000 8091 	beq.w	8001404 <HAL_ADC_Init+0x12c>
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
  {
    assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  }

  if(hadc->State == HAL_ADC_STATE_RESET)
 80012e2:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80012e6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80012ea:	b91b      	cbnz	r3, 80012f4 <HAL_ADC_Init+0x1c>
  {
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 80012ec:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 80012f0:	f7ff fff0 	bl	80012d4 <HAL_ADC_MspInit>
  }

  /* Initialize the ADC state */
  hadc->State = HAL_ADC_STATE_BUSY;
 80012f4:	2302      	movs	r3, #2
 80012f6:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  */
static void ADC_Init(ADC_HandleTypeDef* hadc)
{
  /* Set ADC parameters */
  /* Set the ADC clock prescaler */
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 80012fa:	4b43      	ldr	r3, [pc, #268]	; (8001408 <HAL_ADC_Init+0x130>)
 80012fc:	685a      	ldr	r2, [r3, #4]
 80012fe:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8001302:	605a      	str	r2, [r3, #4]
  ADC->CCR |=  hadc->Init.ClockPrescaler;
 8001304:	6859      	ldr	r1, [r3, #4]
 8001306:	6862      	ldr	r2, [r4, #4]
 8001308:	430a      	orrs	r2, r1
 800130a:	605a      	str	r2, [r3, #4]
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 800130c:	6823      	ldr	r3, [r4, #0]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 800130e:	6921      	ldr	r1, [r4, #16]
  /* Set the ADC clock prescaler */
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
  ADC->CCR |=  hadc->Init.ClockPrescaler;
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8001310:	685a      	ldr	r2, [r3, #4]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8001312:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  /* Set the ADC clock prescaler */
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
  ADC->CCR |=  hadc->Init.ClockPrescaler;
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8001314:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001318:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 800131a:	685a      	ldr	r2, [r3, #4]
 800131c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8001320:	605a      	str	r2, [r3, #4]
  
  /* Set ADC resolution */
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 8001322:	685a      	ldr	r2, [r3, #4]
 8001324:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8001328:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 800132a:	6859      	ldr	r1, [r3, #4]
 800132c:	68a2      	ldr	r2, [r4, #8]
 800132e:	430a      	orrs	r2, r1
 8001330:	605a      	str	r2, [r3, #4]
  
  /* Set ADC data alignment */
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 8001332:	689a      	ldr	r2, [r3, #8]
 8001334:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001338:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 800133a:	6899      	ldr	r1, [r3, #8]
 800133c:	68e2      	ldr	r2, [r4, #12]
 800133e:	430a      	orrs	r2, r1
 8001340:	609a      	str	r2, [r3, #8]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8001342:	4a32      	ldr	r2, [pc, #200]	; (800140c <HAL_ADC_Init+0x134>)
 8001344:	4290      	cmp	r0, r2
 8001346:	d00e      	beq.n	8001366 <HAL_ADC_Init+0x8e>
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8001348:	6899      	ldr	r1, [r3, #8]
 800134a:	f021 6170 	bic.w	r1, r1, #251658240	; 0xf000000
 800134e:	6099      	str	r1, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 8001350:	689a      	ldr	r2, [r3, #8]
 8001352:	4302      	orrs	r2, r0
 8001354:	609a      	str	r2, [r3, #8]
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8001356:	689a      	ldr	r2, [r3, #8]
 8001358:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 800135c:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 800135e:	6899      	ldr	r1, [r3, #8]
 8001360:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8001362:	430a      	orrs	r2, r1
 8001364:	e006      	b.n	8001374 <HAL_ADC_Init+0x9c>
  }
  else
  {
    /* Reset the external trigger */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8001366:	689a      	ldr	r2, [r3, #8]
 8001368:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 800136c:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 800136e:	689a      	ldr	r2, [r3, #8]
 8001370:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8001374:	609a      	str	r2, [r3, #8]
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8001376:	689a      	ldr	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
 8001378:	69a1      	ldr	r1, [r4, #24]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 800137a:	f022 0202 	bic.w	r2, r2, #2
 800137e:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
 8001380:	689a      	ldr	r2, [r3, #8]
 8001382:	ea42 0241 	orr.w	r2, r2, r1, lsl #1
 8001386:	609a      	str	r2, [r3, #8]
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 8001388:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800138a:	b19a      	cbz	r2, 80013b4 <HAL_ADC_Init+0xdc>
  {
    assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
  
    /* Enable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 800138c:	685a      	ldr	r2, [r3, #4]
 800138e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8001392:	605a      	str	r2, [r3, #4]
    
    /* Set the number of channels to be converted in discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 8001394:	685a      	ldr	r2, [r3, #4]
 8001396:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 800139a:	605a      	str	r2, [r3, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800139c:	f44f 4260 	mov.w	r2, #57344	; 0xe000
 80013a0:	fa92 f2a2 	rbit	r2, r2
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 80013a4:	fab2 f182 	clz	r1, r2
 80013a8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80013aa:	6858      	ldr	r0, [r3, #4]
 80013ac:	3a01      	subs	r2, #1
 80013ae:	408a      	lsls	r2, r1
 80013b0:	4302      	orrs	r2, r0
 80013b2:	e002      	b.n	80013ba <HAL_ADC_Init+0xe2>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 80013b4:	685a      	ldr	r2, [r3, #4]
 80013b6:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80013ba:	605a      	str	r2, [r3, #4]
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 80013bc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80013be:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
 80013c2:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 80013c4:	6a22      	ldr	r2, [r4, #32]
 80013c6:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80013c8:	3a01      	subs	r2, #1
 80013ca:	ea41 5202 	orr.w	r2, r1, r2, lsl #20
 80013ce:	62da      	str	r2, [r3, #44]	; 0x2c
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 80013d0:	689a      	ldr	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
 80013d2:	69e1      	ldr	r1, [r4, #28]
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 80013d4:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 80013d8:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
 80013da:	689a      	ldr	r2, [r3, #8]
 80013dc:	ea42 2241 	orr.w	r2, r2, r1, lsl #9
 80013e0:	609a      	str	r2, [r3, #8]
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 80013e2:	689a      	ldr	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 80013e4:	6961      	ldr	r1, [r4, #20]
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 80013e6:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80013ea:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 80013ec:	689a      	ldr	r2, [r3, #8]
 80013ee:	ea42 2281 	orr.w	r2, r2, r1, lsl #10
 80013f2:	609a      	str	r2, [r3, #8]
  
  /* Set ADC parameters */
  ADC_Init(hadc);
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 80013f4:	2000      	movs	r0, #0
  
  /* Initialize the ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 80013f6:	2301      	movs	r3, #1
  
  /* Set ADC parameters */
  ADC_Init(hadc);
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 80013f8:	6420      	str	r0, [r4, #64]	; 0x40
  
  /* Initialize the ADC state */
  hadc->State = HAL_ADC_STATE_READY;

  /* Release Lock */
  __HAL_UNLOCK(hadc);
 80013fa:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
  
  /* Initialize the ADC state */
  hadc->State = HAL_ADC_STATE_READY;
 80013fe:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(hadc);

  /* Return function status */
  return HAL_OK;
 8001402:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
  /* Check ADC handle */
  if(hadc == NULL)
  {
     return HAL_ERROR;
 8001404:	2001      	movs	r0, #1
  /* Release Lock */
  __HAL_UNLOCK(hadc);

  /* Return function status */
  return HAL_OK;
}
 8001406:	bd10      	pop	{r4, pc}
 8001408:	40012300 	.word	0x40012300
 800140c:	0f000001 	.word	0x0f000001

08001410 <HAL_ADC_Start_IT>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
{
 8001410:	b082      	sub	sp, #8
  __IO uint32_t counter = 0;
 8001412:	2300      	movs	r3, #0
 8001414:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8001416:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800141a:	2b01      	cmp	r3, #1
 800141c:	d048      	beq.n	80014b0 <HAL_ADC_Start_IT+0xa0>
 800141e:	2301      	movs	r3, #1
 8001420:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  
  /* Check if an injected conversion is ongoing */
  if(hadc->State == HAL_ADC_STATE_BUSY_INJ)
 8001424:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
  
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8001428:	6802      	ldr	r2, [r0, #0]
  
  /* Process locked */
  __HAL_LOCK(hadc);
  
  /* Check if an injected conversion is ongoing */
  if(hadc->State == HAL_ADC_STATE_BUSY_INJ)
 800142a:	2b22      	cmp	r3, #34	; 0x22
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
 800142c:	bf0c      	ite	eq
 800142e:	2332      	moveq	r3, #50	; 0x32
  }
  else
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_BUSY_REG;
 8001430:	2312      	movne	r3, #18
 8001432:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  } 
  
  /* Set ADC error code to none */
  hadc->ErrorCode = HAL_ADC_ERROR_NONE;
 8001436:	2300      	movs	r3, #0
 8001438:	6403      	str	r3, [r0, #64]	; 0x40
  
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 800143a:	6893      	ldr	r3, [r2, #8]
 800143c:	07db      	lsls	r3, r3, #31
 800143e:	d510      	bpl.n	8001462 <HAL_ADC_Start_IT+0x52>
      counter--;
    }
  }
  
  /* Enable the ADC overrun interrupt */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8001440:	6853      	ldr	r3, [r2, #4]
	
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
  
  /* Check if Multimode enabled */
  if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 8001442:	491e      	ldr	r1, [pc, #120]	; (80014bc <HAL_ADC_Start_IT+0xac>)
      counter--;
    }
  }
  
  /* Enable the ADC overrun interrupt */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8001444:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8001448:	6053      	str	r3, [r2, #4]
  
  /* Enable the ADC end of conversion interrupt for regular group */
  __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOC);
 800144a:	6853      	ldr	r3, [r2, #4]
 800144c:	f043 0320 	orr.w	r3, r3, #32
 8001450:	6053      	str	r3, [r2, #4]
	
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8001452:	2300      	movs	r3, #0
 8001454:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  
  /* Check if Multimode enabled */
  if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 8001458:	6848      	ldr	r0, [r1, #4]
 800145a:	f010 001f 	ands.w	r0, r0, #31
 800145e:	d012      	beq.n	8001486 <HAL_ADC_Start_IT+0x76>
 8001460:	e01a      	b.n	8001498 <HAL_ADC_Start_IT+0x88>
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 8001462:	6893      	ldr	r3, [r2, #8]
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8001464:	4916      	ldr	r1, [pc, #88]	; (80014c0 <HAL_ADC_Start_IT+0xb0>)
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
 8001466:	f043 0301 	orr.w	r3, r3, #1
 800146a:	6093      	str	r3, [r2, #8]
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 800146c:	4b15      	ldr	r3, [pc, #84]	; (80014c4 <HAL_ADC_Start_IT+0xb4>)
 800146e:	681b      	ldr	r3, [r3, #0]
 8001470:	fbb3 f3f1 	udiv	r3, r3, r1
 8001474:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    while(counter != 0)
    {
      counter--;
 8001478:	9301      	str	r3, [sp, #4]
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
    while(counter != 0)
 800147a:	9b01      	ldr	r3, [sp, #4]
 800147c:	2b00      	cmp	r3, #0
 800147e:	d0df      	beq.n	8001440 <HAL_ADC_Start_IT+0x30>
    {
      counter--;
 8001480:	9b01      	ldr	r3, [sp, #4]
 8001482:	3b01      	subs	r3, #1
 8001484:	e7f8      	b.n	8001478 <HAL_ADC_Start_IT+0x68>
  
  /* Check if Multimode enabled */
  if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
  {
    /* if no external trigger present enable software conversion of regular channels */
    if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET)
 8001486:	6893      	ldr	r3, [r2, #8]
 8001488:	f013 5340 	ands.w	r3, r3, #805306368	; 0x30000000
 800148c:	d113      	bne.n	80014b6 <HAL_ADC_Start_IT+0xa6>
    {
      /* Enable the selected ADC software conversion for regular group */
      hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 800148e:	6891      	ldr	r1, [r2, #8]
 8001490:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
 8001494:	6091      	str	r1, [r2, #8]
 8001496:	e00d      	b.n	80014b4 <HAL_ADC_Start_IT+0xa4>
    }
  }
  else
  {
    /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
    if((hadc->Instance == (ADC_TypeDef*)0x40012000) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 8001498:	490b      	ldr	r1, [pc, #44]	; (80014c8 <HAL_ADC_Start_IT+0xb8>)
 800149a:	428a      	cmp	r2, r1
 800149c:	d10a      	bne.n	80014b4 <HAL_ADC_Start_IT+0xa4>
 800149e:	6890      	ldr	r0, [r2, #8]
 80014a0:	f010 5040 	ands.w	r0, r0, #805306368	; 0x30000000
 80014a4:	d106      	bne.n	80014b4 <HAL_ADC_Start_IT+0xa4>
    {
      /* Enable the selected ADC software conversion for regular group */
        hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 80014a6:	6893      	ldr	r3, [r2, #8]
 80014a8:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80014ac:	6093      	str	r3, [r2, #8]
 80014ae:	e002      	b.n	80014b6 <HAL_ADC_Start_IT+0xa6>
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80014b0:	2002      	movs	r0, #2
 80014b2:	e000      	b.n	80014b6 <HAL_ADC_Start_IT+0xa6>
        hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
    }
  }
  
  /* Return function status */
  return HAL_OK;
 80014b4:	4618      	mov	r0, r3
}
 80014b6:	b002      	add	sp, #8
 80014b8:	4770      	bx	lr
 80014ba:	bf00      	nop
 80014bc:	40012300 	.word	0x40012300
 80014c0:	000f4240 	.word	0x000f4240
 80014c4:	20000000 	.word	0x20000000
 80014c8:	40012000 	.word	0x40012000

080014cc <HAL_ADC_GetValue>:
  * @retval Converted value
  */
uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
{       
  /* Return the selected ADC converted value */ 
  return hadc->Instance->DR;
 80014cc:	6803      	ldr	r3, [r0, #0]
 80014ce:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
}
 80014d0:	4770      	bx	lr

080014d2 <HAL_ADC_LevelOutOfWindowCallback>:
 80014d2:	4770      	bx	lr

080014d4 <HAL_ADC_IRQHandler>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
  assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
 80014d4:	6803      	ldr	r3, [r0, #0]
 80014d6:	6819      	ldr	r1, [r3, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
 80014d8:	685a      	ldr	r2, [r3, #4]
  /* Check End of conversion flag for regular channels */
  if(tmp1 && tmp2)
 80014da:	0789      	lsls	r1, r1, #30
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
{
 80014dc:	b510      	push	{r4, lr}
 80014de:	4604      	mov	r4, r0
  assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
  /* Check End of conversion flag for regular channels */
  if(tmp1 && tmp2)
 80014e0:	d529      	bpl.n	8001536 <HAL_ADC_IRQHandler+0x62>
 80014e2:	0690      	lsls	r0, r2, #26
 80014e4:	d527      	bpl.n	8001536 <HAL_ADC_IRQHandler+0x62>
  {
    /* Check if an injected conversion is ready */
    if(hadc->State == HAL_ADC_STATE_EOC_INJ)
 80014e6:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
 80014ea:	2a25      	cmp	r2, #37	; 0x25
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 80014ec:	bf0c      	ite	eq
 80014ee:	2235      	moveq	r2, #53	; 0x35
    }
    else
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_REG;
 80014f0:	2215      	movne	r2, #21
 80014f2:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    }

    if((hadc->Init.ContinuousConvMode == DISABLE) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 80014f6:	69a2      	ldr	r2, [r4, #24]
 80014f8:	b9b2      	cbnz	r2, 8001528 <HAL_ADC_IRQHandler+0x54>
 80014fa:	689a      	ldr	r2, [r3, #8]
 80014fc:	f012 5f40 	tst.w	r2, #805306368	; 0x30000000
 8001500:	d112      	bne.n	8001528 <HAL_ADC_IRQHandler+0x54>
    {
      if(hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 8001502:	6962      	ldr	r2, [r4, #20]
 8001504:	b142      	cbz	r2, 8001518 <HAL_ADC_IRQHandler+0x44>
        /* DISABLE the ADC overrun interrupt */
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
      }
      else
      {
        if (hadc->NbrOfCurrentConversionRank == 0)
 8001506:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001508:	b90a      	cbnz	r2, 800150e <HAL_ADC_IRQHandler+0x3a>
        {
          hadc->NbrOfCurrentConversionRank = hadc->Init.NbrOfConversion;
 800150a:	6a22      	ldr	r2, [r4, #32]
 800150c:	6362      	str	r2, [r4, #52]	; 0x34
        }
        
        /* Decrement the number of conversion when an interrupt occurs */
        hadc->NbrOfCurrentConversionRank--;
 800150e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001510:	3a01      	subs	r2, #1
 8001512:	6362      	str	r2, [r4, #52]	; 0x34
        
        /* Check if all conversions are finished */
        if(hadc->NbrOfCurrentConversionRank == 0)
 8001514:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001516:	b93a      	cbnz	r2, 8001528 <HAL_ADC_IRQHandler+0x54>
        {
          /* DISABLE the ADC end of conversion interrupt for regular group */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 8001518:	685a      	ldr	r2, [r3, #4]
 800151a:	f022 0220 	bic.w	r2, r2, #32
 800151e:	605a      	str	r2, [r3, #4]
          
          /* DISABLE the ADC overrun interrupt */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
 8001520:	685a      	ldr	r2, [r3, #4]
 8001522:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8001526:	605a      	str	r2, [r3, #4]
        }
      }
    }
    
    /* Conversion complete callback */ 
    HAL_ADC_ConvCpltCallback(hadc);
 8001528:	4620      	mov	r0, r4
 800152a:	f7ff f89d 	bl	8000668 <HAL_ADC_ConvCpltCallback>
    
   /* Clear the ADCx flag for regular end of conversion */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_EOC);
 800152e:	6823      	ldr	r3, [r4, #0]
 8001530:	f06f 0202 	mvn.w	r2, #2
 8001534:	601a      	str	r2, [r3, #0]
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC);
 8001536:	6823      	ldr	r3, [r4, #0]
 8001538:	6819      	ldr	r1, [r3, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
 800153a:	685a      	ldr	r2, [r3, #4]
  /* Check End of conversion flag for injected channels */
  if(tmp1 && tmp2)
 800153c:	0749      	lsls	r1, r1, #29
 800153e:	d51d      	bpl.n	800157c <HAL_ADC_IRQHandler+0xa8>
 8001540:	0612      	lsls	r2, r2, #24
 8001542:	d51b      	bpl.n	800157c <HAL_ADC_IRQHandler+0xa8>
  {
    /* Check if a regular conversion is ready */
    if(hadc->State == HAL_ADC_STATE_EOC_REG)
 8001544:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
      hadc->State = HAL_ADC_STATE_EOC_INJ;
    }
    
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
    if(((hadc->Init.ContinuousConvMode == DISABLE) || tmp1) && tmp2)
 8001548:	69a0      	ldr	r0, [r4, #24]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
  /* Check End of conversion flag for injected channels */
  if(tmp1 && tmp2)
  {
    /* Check if a regular conversion is ready */
    if(hadc->State == HAL_ADC_STATE_EOC_REG)
 800154a:	2a15      	cmp	r2, #21
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
 800154c:	bf0c      	ite	eq
 800154e:	2235      	moveq	r2, #53	; 0x35
    }
    else
    {
      /* Change ADC state */
      hadc->State = HAL_ADC_STATE_EOC_INJ;
 8001550:	2225      	movne	r2, #37	; 0x25
 8001552:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    }
    
    tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
 8001556:	6859      	ldr	r1, [r3, #4]
    tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
 8001558:	689a      	ldr	r2, [r3, #8]
 800155a:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
    if(((hadc->Init.ContinuousConvMode == DISABLE) || tmp1) && tmp2)
 800155e:	b108      	cbz	r0, 8001564 <HAL_ADC_IRQHandler+0x90>
 8001560:	0548      	lsls	r0, r1, #21
 8001562:	d404      	bmi.n	800156e <HAL_ADC_IRQHandler+0x9a>
 8001564:	b91a      	cbnz	r2, 800156e <HAL_ADC_IRQHandler+0x9a>
    {
      /* DISABLE the ADC end of conversion interrupt for injected group */
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
 8001566:	685a      	ldr	r2, [r3, #4]
 8001568:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800156c:	605a      	str	r2, [r3, #4]
    }
    
    /* Conversion complete callback */ 
    HAL_ADCEx_InjectedConvCpltCallback(hadc);
 800156e:	4620      	mov	r0, r4
 8001570:	f000 f8c0 	bl	80016f4 <HAL_ADCEx_InjectedConvCpltCallback>
    
   /* Clear the ADCx flag for injected end of conversion */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_JEOC);
 8001574:	6823      	ldr	r3, [r4, #0]
 8001576:	f06f 0204 	mvn.w	r2, #4
 800157a:	601a      	str	r2, [r3, #0]
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD);
 800157c:	6823      	ldr	r3, [r4, #0]
 800157e:	6819      	ldr	r1, [r3, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD);                          
 8001580:	685a      	ldr	r2, [r3, #4]
  /* Check Analog watchdog flag */
  if(tmp1 && tmp2)
 8001582:	07c9      	lsls	r1, r1, #31
 8001584:	d50a      	bpl.n	800159c <HAL_ADC_IRQHandler+0xc8>
 8001586:	0650      	lsls	r0, r2, #25
 8001588:	d508      	bpl.n	800159c <HAL_ADC_IRQHandler+0xc8>
  {
    /* Change ADC state */
    hadc->State = HAL_ADC_STATE_AWD;
 800158a:	2206      	movs	r2, #6
 800158c:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
      
    /* Clear the ADCx's Analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_AWD);
 8001590:	f06f 0201 	mvn.w	r2, #1
 8001594:	601a      	str	r2, [r3, #0]
    
    /* Level out of window callback */ 
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 8001596:	4620      	mov	r0, r4
 8001598:	f7ff ff9b 	bl	80014d2 <HAL_ADC_LevelOutOfWindowCallback>
  }
  
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR);
 800159c:	6823      	ldr	r3, [r4, #0]
 800159e:	6819      	ldr	r1, [r3, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR);
 80015a0:	685a      	ldr	r2, [r3, #4]
  /* Check Overrun flag */
  if(tmp1 && tmp2)
 80015a2:	0689      	lsls	r1, r1, #26
 80015a4:	d50e      	bpl.n	80015c4 <HAL_ADC_IRQHandler+0xf0>
 80015a6:	0152      	lsls	r2, r2, #5
 80015a8:	d50c      	bpl.n	80015c4 <HAL_ADC_IRQHandler+0xf0>
  {
    /* Change ADC state to overrun state */
    hadc->State = HAL_ADC_STATE_ERROR;
 80015aa:	2204      	movs	r2, #4
 80015ac:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    
    /* Set ADC error code to overrun */
    hadc->ErrorCode |= HAL_ADC_ERROR_OVR;
 80015b0:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80015b2:	f042 0201 	orr.w	r2, r2, #1
 80015b6:	6422      	str	r2, [r4, #64]	; 0x40
    
    /* Clear the Overrun flag */
    __HAL_ADC_CLEAR_FLAG(hadc,ADC_FLAG_OVR);
 80015b8:	f06f 0220 	mvn.w	r2, #32
 80015bc:	601a      	str	r2, [r3, #0]
    
    /* Error callback */ 
    HAL_ADC_ErrorCallback(hadc);
 80015be:	4620      	mov	r0, r4
 80015c0:	f7ff f84a 	bl	8000658 <HAL_ADC_ErrorCallback>
 80015c4:	bd10      	pop	{r4, pc}
	...

080015c8 <HAL_ADC_ConfigChannel>:
  *         the configuration information for the specified ADC.
  * @param  sConfig: ADC configuration structure. 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 80015c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint32_t counter = 0;
 80015ca:	2300      	movs	r3, #0
 80015cc:	9301      	str	r3, [sp, #4]
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80015ce:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80015d2:	2b01      	cmp	r3, #1
 80015d4:	d069      	beq.n	80016aa <HAL_ADC_ConfigChannel+0xe2>
    
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfig->Channel > ADC_CHANNEL_9)
 80015d6:	680d      	ldr	r5, [r1, #0]
 80015d8:	6804      	ldr	r4, [r0, #0]
 80015da:	688f      	ldr	r7, [r1, #8]
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80015dc:	2301      	movs	r3, #1
    
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfig->Channel > ADC_CHANNEL_9)
 80015de:	2d09      	cmp	r5, #9
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80015e0:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
 80015e4:	b2ae      	uxth	r6, r5
    
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfig->Channel > ADC_CHANNEL_9)
 80015e6:	d910      	bls.n	800160a <HAL_ADC_ConfigChannel+0x42>
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 80015e8:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 80015ec:	f8d4 e00c 	ldr.w	lr, [r4, #12]
 80015f0:	f1a2 031e 	sub.w	r3, r2, #30
 80015f4:	2207      	movs	r2, #7
 80015f6:	409a      	lsls	r2, r3
 80015f8:	ea2e 0202 	bic.w	r2, lr, r2
 80015fc:	60e2      	str	r2, [r4, #12]
    
    /* Set the new sample time */
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 80015fe:	68e2      	ldr	r2, [r4, #12]
 8001600:	fa07 f303 	lsl.w	r3, r7, r3
 8001604:	4313      	orrs	r3, r2
 8001606:	60e3      	str	r3, [r4, #12]
 8001608:	e00e      	b.n	8001628 <HAL_ADC_ConfigChannel+0x60>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 800160a:	6922      	ldr	r2, [r4, #16]
 800160c:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8001610:	f04f 0e07 	mov.w	lr, #7
 8001614:	fa0e fe03 	lsl.w	lr, lr, r3
 8001618:	ea22 020e 	bic.w	r2, r2, lr
 800161c:	6122      	str	r2, [r4, #16]
    
    /* Set the new sample time */
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 800161e:	6922      	ldr	r2, [r4, #16]
 8001620:	fa07 f303 	lsl.w	r3, r7, r3
 8001624:	4313      	orrs	r3, r2
 8001626:	6123      	str	r3, [r4, #16]
  }
  
  /* For Rank 1 to 6 */
  if (sConfig->Rank < 7)
 8001628:	684b      	ldr	r3, [r1, #4]
 800162a:	2b06      	cmp	r3, #6
 800162c:	ea4f 0283 	mov.w	r2, r3, lsl #2
 8001630:	d80d      	bhi.n	800164e <HAL_ADC_ConfigChannel+0x86>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 8001632:	4413      	add	r3, r2
 8001634:	6b67      	ldr	r7, [r4, #52]	; 0x34
 8001636:	1f59      	subs	r1, r3, #5
 8001638:	231f      	movs	r3, #31
 800163a:	408b      	lsls	r3, r1
 800163c:	ea27 0303 	bic.w	r3, r7, r3
 8001640:	6363      	str	r3, [r4, #52]	; 0x34
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 8001642:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001644:	fa06 f101 	lsl.w	r1, r6, r1
 8001648:	4311      	orrs	r1, r2
 800164a:	6361      	str	r1, [r4, #52]	; 0x34
 800164c:	e01d      	b.n	800168a <HAL_ADC_ConfigChannel+0xc2>
  }
  /* For Rank 7 to 12 */
  else if (sConfig->Rank < 13)
 800164e:	2b0c      	cmp	r3, #12
 8001650:	d80e      	bhi.n	8001670 <HAL_ADC_ConfigChannel+0xa8>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 8001652:	4413      	add	r3, r2
 8001654:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8001656:	f1a3 0223 	sub.w	r2, r3, #35	; 0x23
 800165a:	231f      	movs	r3, #31
 800165c:	4093      	lsls	r3, r2
 800165e:	ea21 0303 	bic.w	r3, r1, r3
 8001662:	6323      	str	r3, [r4, #48]	; 0x30
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 8001664:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001666:	fa06 f202 	lsl.w	r2, r6, r2
 800166a:	431a      	orrs	r2, r3
 800166c:	6322      	str	r2, [r4, #48]	; 0x30
 800166e:	e00c      	b.n	800168a <HAL_ADC_ConfigChannel+0xc2>
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 8001670:	4413      	add	r3, r2
 8001672:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 8001674:	3b41      	subs	r3, #65	; 0x41
 8001676:	221f      	movs	r2, #31
 8001678:	409a      	lsls	r2, r3
 800167a:	ea27 0202 	bic.w	r2, r7, r2
 800167e:	62e2      	str	r2, [r4, #44]	; 0x2c
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8001680:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8001682:	fa06 f203 	lsl.w	r2, r6, r3
 8001686:	430a      	orrs	r2, r1
 8001688:	62e2      	str	r2, [r4, #44]	; 0x2c
  }
  
  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 800168a:	4b16      	ldr	r3, [pc, #88]	; (80016e4 <HAL_ADC_ConfigChannel+0x11c>)
 800168c:	429c      	cmp	r4, r3
 800168e:	d004      	beq.n	800169a <HAL_ADC_ConfigChannel+0xd2>
      }
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8001690:	2300      	movs	r3, #0
 8001692:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 8001696:	4618      	mov	r0, r3
 8001698:	e022      	b.n	80016e0 <HAL_ADC_ConfigChannel+0x118>
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
  }
  
  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 800169a:	2d12      	cmp	r5, #18
 800169c:	d107      	bne.n	80016ae <HAL_ADC_ConfigChannel+0xe6>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= ADC_CCR_VBATE;
 800169e:	4a12      	ldr	r2, [pc, #72]	; (80016e8 <HAL_ADC_ConfigChannel+0x120>)
 80016a0:	6853      	ldr	r3, [r2, #4]
 80016a2:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80016a6:	6053      	str	r3, [r2, #4]
 80016a8:	e001      	b.n	80016ae <HAL_ADC_ConfigChannel+0xe6>
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80016aa:	2002      	movs	r0, #2
 80016ac:	e018      	b.n	80016e0 <HAL_ADC_ConfigChannel+0x118>
    /* Enable the VBAT channel*/
    ADC->CCR |= ADC_CCR_VBATE;
  }
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 80016ae:	f1a5 0310 	sub.w	r3, r5, #16
 80016b2:	2b01      	cmp	r3, #1
 80016b4:	d8ec      	bhi.n	8001690 <HAL_ADC_ConfigChannel+0xc8>
  {
    /* Enable the TSVREFE channel*/
    ADC->CCR |= ADC_CCR_TSVREFE;
 80016b6:	4a0c      	ldr	r2, [pc, #48]	; (80016e8 <HAL_ADC_ConfigChannel+0x120>)
 80016b8:	6853      	ldr	r3, [r2, #4]

    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 80016ba:	2d10      	cmp	r5, #16
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
  {
    /* Enable the TSVREFE channel*/
    ADC->CCR |= ADC_CCR_TSVREFE;
 80016bc:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80016c0:	6053      	str	r3, [r2, #4]

    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 80016c2:	d1e5      	bne.n	8001690 <HAL_ADC_ConfigChannel+0xc8>
    {
      /* Delay for temperature sensor stabilization time */
      /* Compute number of CPU cycles to wait for */
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
 80016c4:	4b09      	ldr	r3, [pc, #36]	; (80016ec <HAL_ADC_ConfigChannel+0x124>)
 80016c6:	4a0a      	ldr	r2, [pc, #40]	; (80016f0 <HAL_ADC_ConfigChannel+0x128>)
 80016c8:	681b      	ldr	r3, [r3, #0]
 80016ca:	fbb3 f2f2 	udiv	r2, r3, r2
 80016ce:	230a      	movs	r3, #10
 80016d0:	4353      	muls	r3, r2
      while(counter != 0)
      {
        counter--;
 80016d2:	9301      	str	r3, [sp, #4]
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
    {
      /* Delay for temperature sensor stabilization time */
      /* Compute number of CPU cycles to wait for */
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
      while(counter != 0)
 80016d4:	9b01      	ldr	r3, [sp, #4]
 80016d6:	2b00      	cmp	r3, #0
 80016d8:	d0da      	beq.n	8001690 <HAL_ADC_ConfigChannel+0xc8>
      {
        counter--;
 80016da:	9b01      	ldr	r3, [sp, #4]
 80016dc:	3b01      	subs	r3, #1
 80016de:	e7f8      	b.n	80016d2 <HAL_ADC_ConfigChannel+0x10a>
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
  
  /* Return function status */
  return HAL_OK;
}
 80016e0:	b003      	add	sp, #12
 80016e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80016e4:	40012000 	.word	0x40012000
 80016e8:	40012300 	.word	0x40012300
 80016ec:	20000000 	.word	0x20000000
 80016f0:	000f4240 	.word	0x000f4240

080016f4 <HAL_ADCEx_InjectedConvCpltCallback>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  */
__weak void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc)
{
 80016f4:	4770      	bx	lr
	...

080016f8 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80016f8:	4a07      	ldr	r2, [pc, #28]	; (8001718 <HAL_NVIC_SetPriorityGrouping+0x20>)
 80016fa:	68d3      	ldr	r3, [r2, #12]
 80016fc:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001700:	041b      	lsls	r3, r3, #16
 8001702:	0c1b      	lsrs	r3, r3, #16
 8001704:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8001708:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800170c:	f000 0007 	and.w	r0, r0, #7
 8001710:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8001714:	60d3      	str	r3, [r2, #12]
 8001716:	4770      	bx	lr
 8001718:	e000ed00 	.word	0xe000ed00

0800171c <HAL_NVIC_SetPriority>:

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800171c:	4b17      	ldr	r3, [pc, #92]	; (800177c <HAL_NVIC_SetPriority+0x60>)
 800171e:	68db      	ldr	r3, [r3, #12]
 8001720:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8001724:	b530      	push	{r4, r5, lr}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001726:	f1c3 0407 	rsb	r4, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800172a:	1d1d      	adds	r5, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800172c:	2c04      	cmp	r4, #4
 800172e:	bf28      	it	cs
 8001730:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001732:	2d06      	cmp	r5, #6

  return (
 8001734:	f04f 0501 	mov.w	r5, #1
 8001738:	fa05 f404 	lsl.w	r4, r5, r4
 800173c:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001740:	bf8c      	ite	hi
 8001742:	3b03      	subhi	r3, #3
 8001744:	2300      	movls	r3, #0

  return (
 8001746:	400c      	ands	r4, r1
 8001748:	409c      	lsls	r4, r3
 800174a:	fa05 f303 	lsl.w	r3, r5, r3
 800174e:	3b01      	subs	r3, #1
 8001750:	401a      	ands	r2, r3
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
 8001752:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8001754:	ea42 0204 	orr.w	r2, r2, r4
 8001758:	ea4f 1202 	mov.w	r2, r2, lsl #4
{
  if((int32_t)IRQn < 0) {
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800175c:	bfaf      	iteee	ge
 800175e:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001762:	f000 000f 	andlt.w	r0, r0, #15
 8001766:	4b06      	ldrlt	r3, [pc, #24]	; (8001780 <HAL_NVIC_SetPriority+0x64>)
 8001768:	b2d2      	uxtblt	r2, r2
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800176a:	bfa5      	ittet	ge
 800176c:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 8001770:	b2d2      	uxtbge	r2, r2
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001772:	541a      	strblt	r2, [r3, r0]
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001774:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8001778:	bd30      	pop	{r4, r5, pc}
 800177a:	bf00      	nop
 800177c:	e000ed00 	.word	0xe000ed00
 8001780:	e000ed14 	.word	0xe000ed14

08001784 <HAL_NVIC_EnableIRQ>:

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8001784:	0942      	lsrs	r2, r0, #5
 8001786:	2301      	movs	r3, #1
 8001788:	f000 001f 	and.w	r0, r0, #31
 800178c:	fa03 f000 	lsl.w	r0, r3, r0
 8001790:	4b01      	ldr	r3, [pc, #4]	; (8001798 <HAL_NVIC_EnableIRQ+0x14>)
 8001792:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8001796:	4770      	bx	lr
 8001798:	e000e100 	.word	0xe000e100

0800179c <HAL_SYSTICK_Config>:
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 800179c:	3801      	subs	r0, #1
 800179e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80017a2:	d20a      	bcs.n	80017ba <HAL_SYSTICK_Config+0x1e>

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80017a4:	4b06      	ldr	r3, [pc, #24]	; (80017c0 <HAL_SYSTICK_Config+0x24>)
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80017a6:	4a07      	ldr	r2, [pc, #28]	; (80017c4 <HAL_SYSTICK_Config+0x28>)
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80017a8:	6058      	str	r0, [r3, #4]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80017aa:	21f0      	movs	r1, #240	; 0xf0
 80017ac:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80017b0:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80017b2:	2207      	movs	r2, #7
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80017b4:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80017b6:	601a      	str	r2, [r3, #0]
 80017b8:	4770      	bx	lr
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 80017ba:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80017bc:	4770      	bx	lr
 80017be:	bf00      	nop
 80017c0:	e000e010 	.word	0xe000e010
 80017c4:	e000ed00 	.word	0xe000ed00

080017c8 <HAL_MPU_ConfigRegion>:
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 80017c8:	4911      	ldr	r1, [pc, #68]	; (8001810 <HAL_MPU_ConfigRegion+0x48>)
 80017ca:	7843      	ldrb	r3, [r0, #1]
 80017cc:	608b      	str	r3, [r1, #8]

  if ((MPU_Init->Enable) != RESET)
 80017ce:	7803      	ldrb	r3, [r0, #0]
 80017d0:	b1db      	cbz	r3, 800180a <HAL_MPU_ConfigRegion+0x42>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
 80017d2:	6843      	ldr	r3, [r0, #4]
 80017d4:	60cb      	str	r3, [r1, #12]
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80017d6:	7ac3      	ldrb	r3, [r0, #11]
 80017d8:	7b02      	ldrb	r2, [r0, #12]
 80017da:	061b      	lsls	r3, r3, #24
 80017dc:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 80017e0:	7802      	ldrb	r2, [r0, #0]
 80017e2:	4313      	orrs	r3, r2
 80017e4:	7a82      	ldrb	r2, [r0, #10]
 80017e6:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 80017ea:	7b42      	ldrb	r2, [r0, #13]
 80017ec:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
 80017f0:	7b82      	ldrb	r2, [r0, #14]
 80017f2:	ea43 4342 	orr.w	r3, r3, r2, lsl #17
 80017f6:	7bc2      	ldrb	r2, [r0, #15]
 80017f8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80017fc:	7a42      	ldrb	r2, [r0, #9]
 80017fe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001802:	7a02      	ldrb	r2, [r0, #8]
 8001804:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
 8001808:	e000      	b.n	800180c <HAL_MPU_ConfigRegion+0x44>
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
  }
  else
  {
    MPU->RBAR = 0x00;
 800180a:	60cb      	str	r3, [r1, #12]
    MPU->RASR = 0x00;
 800180c:	610b      	str	r3, [r1, #16]
 800180e:	4770      	bx	lr
 8001810:	e000ed90 	.word	0xe000ed90

08001814 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001814:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001818:	4e6f      	ldr	r6, [pc, #444]	; (80019d8 <HAL_GPIO_Init+0x1c4>)
  for(position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800181a:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800181c:	f8df c1c0 	ldr.w	ip, [pc, #448]	; 80019e0 <HAL_GPIO_Init+0x1cc>

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8001820:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 80019e4 <HAL_GPIO_Init+0x1d0>
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001824:	b085      	sub	sp, #20
 8001826:	46b6      	mov	lr, r6
  for(position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001828:	9301      	str	r3, [sp, #4]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800182a:	2300      	movs	r3, #0
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 800182c:	2201      	movs	r2, #1
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 800182e:	9c01      	ldr	r4, [sp, #4]

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8001830:	409a      	lsls	r2, r3
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 8001832:	ea32 0404 	bics.w	r4, r2, r4
 8001836:	f040 80c7 	bne.w	80019c8 <HAL_GPIO_Init+0x1b4>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800183a:	684c      	ldr	r4, [r1, #4]
 800183c:	f024 0910 	bic.w	r9, r4, #16
 8001840:	f1b9 0f02 	cmp.w	r9, #2
 8001844:	d114      	bne.n	8001870 <HAL_GPIO_Init+0x5c>
 8001846:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 800184a:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800184e:	f003 0b07 	and.w	fp, r3, #7
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8001852:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001856:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 800185a:	250f      	movs	r5, #15
 800185c:	fa05 f50b 	lsl.w	r5, r5, fp
 8001860:	ea27 0505 	bic.w	r5, r7, r5
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8001864:	690f      	ldr	r7, [r1, #16]
 8001866:	fa07 f70b 	lsl.w	r7, r7, fp
 800186a:	432f      	orrs	r7, r5
        GPIOx->AFR[position >> 3] = temp;
 800186c:	f8ca 7020 	str.w	r7, [sl, #32]
 8001870:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001874:	2503      	movs	r5, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8001876:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001878:	fa05 f50a 	lsl.w	r5, r5, sl
 800187c:	43ed      	mvns	r5, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800187e:	f004 0b03 	and.w	fp, r4, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001882:	402f      	ands	r7, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001884:	fa0b fb0a 	lsl.w	fp, fp, sl
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001888:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800188c:	ea4b 0707 	orr.w	r7, fp, r7
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001890:	f1b9 0f01 	cmp.w	r9, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;
 8001894:	6007      	str	r7, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001896:	d812      	bhi.n	80018be <HAL_GPIO_Init+0xaa>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8001898:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 800189a:	ea05 0907 	and.w	r9, r5, r7
        temp |= (GPIO_Init->Speed << (position * 2));
 800189e:	68cf      	ldr	r7, [r1, #12]
 80018a0:	fa07 f70a 	lsl.w	r7, r7, sl
 80018a4:	ea47 0709 	orr.w	r7, r7, r9
        GPIOx->OSPEEDR = temp;
 80018a8:	6087      	str	r7, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 80018aa:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 80018ac:	f3c4 1900 	ubfx	r9, r4, #4, #1
        temp |= (GPIO_Init->Speed << (position * 2));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80018b0:	ea27 0702 	bic.w	r7, r7, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 80018b4:	fa09 f903 	lsl.w	r9, r9, r3
 80018b8:	ea49 0707 	orr.w	r7, r9, r7
        GPIOx->OTYPER = temp;
 80018bc:	6047      	str	r7, [r0, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 80018be:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 80018c0:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2));
 80018c2:	688f      	ldr	r7, [r1, #8]
 80018c4:	fa07 f70a 	lsl.w	r7, r7, sl
 80018c8:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 80018ca:	60c5      	str	r5, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80018cc:	00e5      	lsls	r5, r4, #3
 80018ce:	d57b      	bpl.n	80019c8 <HAL_GPIO_Init+0x1b4>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80018d0:	f8dc 5044 	ldr.w	r5, [ip, #68]	; 0x44
 80018d4:	f445 4580 	orr.w	r5, r5, #16384	; 0x4000
 80018d8:	f8cc 5044 	str.w	r5, [ip, #68]	; 0x44
 80018dc:	f8dc 5044 	ldr.w	r5, [ip, #68]	; 0x44
 80018e0:	f023 0703 	bic.w	r7, r3, #3
 80018e4:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 80018e8:	f405 4580 	and.w	r5, r5, #16384	; 0x4000
 80018ec:	f507 379c 	add.w	r7, r7, #79872	; 0x13800
 80018f0:	9503      	str	r5, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80018f2:	f003 0a03 	and.w	sl, r3, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80018f6:	9d03      	ldr	r5, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2];
 80018f8:	f8d7 b008 	ldr.w	fp, [r7, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80018fc:	f04f 090f 	mov.w	r9, #15
 8001900:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8001904:	fa09 f50a 	lsl.w	r5, r9, sl
 8001908:	ea2b 0905 	bic.w	r9, fp, r5
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800190c:	4d33      	ldr	r5, [pc, #204]	; (80019dc <HAL_GPIO_Init+0x1c8>)
 800190e:	42a8      	cmp	r0, r5
 8001910:	d024      	beq.n	800195c <HAL_GPIO_Init+0x148>
 8001912:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001916:	42a8      	cmp	r0, r5
 8001918:	d022      	beq.n	8001960 <HAL_GPIO_Init+0x14c>
 800191a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800191e:	42a8      	cmp	r0, r5
 8001920:	d020      	beq.n	8001964 <HAL_GPIO_Init+0x150>
 8001922:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001926:	42a8      	cmp	r0, r5
 8001928:	d01e      	beq.n	8001968 <HAL_GPIO_Init+0x154>
 800192a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800192e:	42a8      	cmp	r0, r5
 8001930:	d01c      	beq.n	800196c <HAL_GPIO_Init+0x158>
 8001932:	4540      	cmp	r0, r8
 8001934:	d01c      	beq.n	8001970 <HAL_GPIO_Init+0x15c>
 8001936:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800193a:	42a8      	cmp	r0, r5
 800193c:	d01a      	beq.n	8001974 <HAL_GPIO_Init+0x160>
 800193e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001942:	42a8      	cmp	r0, r5
 8001944:	d018      	beq.n	8001978 <HAL_GPIO_Init+0x164>
 8001946:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800194a:	42a8      	cmp	r0, r5
 800194c:	d016      	beq.n	800197c <HAL_GPIO_Init+0x168>
 800194e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001952:	42a8      	cmp	r0, r5
 8001954:	bf14      	ite	ne
 8001956:	250a      	movne	r5, #10
 8001958:	2509      	moveq	r5, #9
 800195a:	e010      	b.n	800197e <HAL_GPIO_Init+0x16a>
 800195c:	2500      	movs	r5, #0
 800195e:	e00e      	b.n	800197e <HAL_GPIO_Init+0x16a>
 8001960:	2501      	movs	r5, #1
 8001962:	e00c      	b.n	800197e <HAL_GPIO_Init+0x16a>
 8001964:	2502      	movs	r5, #2
 8001966:	e00a      	b.n	800197e <HAL_GPIO_Init+0x16a>
 8001968:	2503      	movs	r5, #3
 800196a:	e008      	b.n	800197e <HAL_GPIO_Init+0x16a>
 800196c:	2504      	movs	r5, #4
 800196e:	e006      	b.n	800197e <HAL_GPIO_Init+0x16a>
 8001970:	2505      	movs	r5, #5
 8001972:	e004      	b.n	800197e <HAL_GPIO_Init+0x16a>
 8001974:	2506      	movs	r5, #6
 8001976:	e002      	b.n	800197e <HAL_GPIO_Init+0x16a>
 8001978:	2507      	movs	r5, #7
 800197a:	e000      	b.n	800197e <HAL_GPIO_Init+0x16a>
 800197c:	2508      	movs	r5, #8
 800197e:	fa05 f50a 	lsl.w	r5, r5, sl
 8001982:	ea45 0509 	orr.w	r5, r5, r9
        SYSCFG->EXTICR[position >> 2] = temp;
 8001986:	60bd      	str	r5, [r7, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001988:	6835      	ldr	r5, [r6, #0]
        temp &= ~((uint32_t)iocurrent);
 800198a:	43d7      	mvns	r7, r2
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800198c:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 8001990:	bf0c      	ite	eq
 8001992:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 8001994:	4315      	orrne	r5, r2
        }
        EXTI->IMR = temp;
 8001996:	f8ce 5000 	str.w	r5, [lr]

        temp = EXTI->EMR;
 800199a:	f8de 5004 	ldr.w	r5, [lr, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800199e:	f414 3f00 	tst.w	r4, #131072	; 0x20000
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
 80019a2:	bf0c      	ite	eq
 80019a4:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 80019a6:	4315      	orrne	r5, r2
        }
        EXTI->EMR = temp;
 80019a8:	6075      	str	r5, [r6, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 80019aa:	68b5      	ldr	r5, [r6, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80019ac:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        }
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
 80019b0:	bf0c      	ite	eq
 80019b2:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 80019b4:	4315      	orrne	r5, r2
        }
        EXTI->RTSR = temp;
 80019b6:	f8ce 5008 	str.w	r5, [lr, #8]

        temp = EXTI->FTSR;
 80019ba:	f8de 500c 	ldr.w	r5, [lr, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80019be:	02a4      	lsls	r4, r4, #10
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
 80019c0:	bf54      	ite	pl
 80019c2:	403d      	andpl	r5, r7
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 80019c4:	4315      	orrmi	r5, r2
        }
        EXTI->FTSR = temp;
 80019c6:	60f5      	str	r5, [r6, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 80019c8:	3301      	adds	r3, #1
 80019ca:	2b10      	cmp	r3, #16
 80019cc:	f47f af2e 	bne.w	800182c <HAL_GPIO_Init+0x18>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 80019d0:	b005      	add	sp, #20
 80019d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80019d6:	bf00      	nop
 80019d8:	40013c00 	.word	0x40013c00
 80019dc:	40020000 	.word	0x40020000
 80019e0:	40023800 	.word	0x40023800
 80019e4:	40021400 	.word	0x40021400

080019e8 <HAL_PWREx_EnableOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 80019e8:	4b19      	ldr	r3, [pc, #100]	; (8001a50 <HAL_PWREx_EnableOverDrive+0x68>)
 80019ea:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 80019ec:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 80019ee:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80019f2:	641a      	str	r2, [r3, #64]	; 0x40
 80019f4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 80019f6:	4c17      	ldr	r4, [pc, #92]	; (8001a54 <HAL_PWREx_EnableOverDrive+0x6c>)
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 80019f8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80019fc:	9301      	str	r3, [sp, #4]
 80019fe:	9b01      	ldr	r3, [sp, #4]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8001a00:	6823      	ldr	r3, [r4, #0]
 8001a02:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001a06:	6023      	str	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8001a08:	f7ff fc5e 	bl	80012c8 <HAL_GetTick>

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8001a0c:	4625      	mov	r5, r4
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();

  /* Get tick */
  tickstart = HAL_GetTick();
 8001a0e:	4606      	mov	r6, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8001a10:	686b      	ldr	r3, [r5, #4]
 8001a12:	4c10      	ldr	r4, [pc, #64]	; (8001a54 <HAL_PWREx_EnableOverDrive+0x6c>)
 8001a14:	03da      	lsls	r2, r3, #15
 8001a16:	d407      	bmi.n	8001a28 <HAL_PWREx_EnableOverDrive+0x40>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8001a18:	f7ff fc56 	bl	80012c8 <HAL_GetTick>
 8001a1c:	1b80      	subs	r0, r0, r6
 8001a1e:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8001a22:	d9f5      	bls.n	8001a10 <HAL_PWREx_EnableOverDrive+0x28>
    {
      return HAL_TIMEOUT;
 8001a24:	2003      	movs	r0, #3
 8001a26:	e011      	b.n	8001a4c <HAL_PWREx_EnableOverDrive+0x64>
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8001a28:	6823      	ldr	r3, [r4, #0]
 8001a2a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001a2e:	6023      	str	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8001a30:	f7ff fc4a 	bl	80012c8 <HAL_GetTick>
 8001a34:	4605      	mov	r5, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8001a36:	6863      	ldr	r3, [r4, #4]
 8001a38:	039b      	lsls	r3, r3, #14
 8001a3a:	d406      	bmi.n	8001a4a <HAL_PWREx_EnableOverDrive+0x62>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8001a3c:	f7ff fc44 	bl	80012c8 <HAL_GetTick>
 8001a40:	1b40      	subs	r0, r0, r5
 8001a42:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8001a46:	d9f6      	bls.n	8001a36 <HAL_PWREx_EnableOverDrive+0x4e>
 8001a48:	e7ec      	b.n	8001a24 <HAL_PWREx_EnableOverDrive+0x3c>
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 8001a4a:	2000      	movs	r0, #0
}
 8001a4c:	b002      	add	sp, #8
 8001a4e:	bd70      	pop	{r4, r5, r6, pc}
 8001a50:	40023800 	.word	0x40023800
 8001a54:	40007000 	.word	0x40007000

08001a58 <HAL_RCC_OscConfig>:
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001a58:	6803      	ldr	r3, [r0, #0]
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001a5a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001a5e:	07dd      	lsls	r5, r3, #31
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001a60:	4604      	mov	r4, r0
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001a62:	d403      	bmi.n	8001a6c <HAL_RCC_OscConfig+0x14>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001a64:	6823      	ldr	r3, [r4, #0]
 8001a66:	0798      	lsls	r0, r3, #30
 8001a68:	d470      	bmi.n	8001b4c <HAL_RCC_OscConfig+0xf4>
 8001a6a:	e0c3      	b.n	8001bf4 <HAL_RCC_OscConfig+0x19c>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 8001a6c:	4ba3      	ldr	r3, [pc, #652]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
 8001a6e:	689a      	ldr	r2, [r3, #8]
 8001a70:	f002 020c 	and.w	r2, r2, #12
 8001a74:	2a04      	cmp	r2, #4
 8001a76:	d007      	beq.n	8001a88 <HAL_RCC_OscConfig+0x30>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001a78:	689a      	ldr	r2, [r3, #8]
 8001a7a:	f002 020c 	and.w	r2, r2, #12
 8001a7e:	2a08      	cmp	r2, #8
 8001a80:	d10b      	bne.n	8001a9a <HAL_RCC_OscConfig+0x42>
 8001a82:	685b      	ldr	r3, [r3, #4]
 8001a84:	0259      	lsls	r1, r3, #9
 8001a86:	d508      	bpl.n	8001a9a <HAL_RCC_OscConfig+0x42>
    {
	  if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001a88:	4b9c      	ldr	r3, [pc, #624]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
 8001a8a:	681b      	ldr	r3, [r3, #0]
 8001a8c:	039a      	lsls	r2, r3, #14
 8001a8e:	d5e9      	bpl.n	8001a64 <HAL_RCC_OscConfig+0xc>
 8001a90:	6863      	ldr	r3, [r4, #4]
 8001a92:	2b00      	cmp	r3, #0
 8001a94:	d1e6      	bne.n	8001a64 <HAL_RCC_OscConfig+0xc>
      {
        return HAL_ERROR;
 8001a96:	2001      	movs	r0, #1
 8001a98:	e1af      	b.n	8001dfa <HAL_RCC_OscConfig+0x3a2>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 8001a9a:	4d98      	ldr	r5, [pc, #608]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
 8001a9c:	682b      	ldr	r3, [r5, #0]
 8001a9e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001aa2:	602b      	str	r3, [r5, #0]
 8001aa4:	682b      	ldr	r3, [r5, #0]
 8001aa6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001aaa:	602b      	str	r3, [r5, #0]
 8001aac:	682b      	ldr	r3, [r5, #0]
 8001aae:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001ab2:	602b      	str	r3, [r5, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001ab4:	f7ff fc08 	bl	80012c8 <HAL_GetTick>
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001ab8:	462e      	mov	r6, r5
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001aba:	4607      	mov	r7, r0
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001abc:	6833      	ldr	r3, [r6, #0]
 8001abe:	4d8f      	ldr	r5, [pc, #572]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
 8001ac0:	039b      	lsls	r3, r3, #14
 8001ac2:	d507      	bpl.n	8001ad4 <HAL_RCC_OscConfig+0x7c>
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001ac4:	f7ff fc00 	bl	80012c8 <HAL_GetTick>
 8001ac8:	1bc0      	subs	r0, r0, r7
 8001aca:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 8001ace:	d9f5      	bls.n	8001abc <HAL_RCC_OscConfig+0x64>
        {
          return HAL_TIMEOUT;
 8001ad0:	2003      	movs	r0, #3
 8001ad2:	e192      	b.n	8001dfa <HAL_RCC_OscConfig+0x3a2>
        }
      }
      
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001ad4:	682b      	ldr	r3, [r5, #0]
 8001ad6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001ada:	602b      	str	r3, [r5, #0]
 8001adc:	6863      	ldr	r3, [r4, #4]
 8001ade:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001ae2:	d103      	bne.n	8001aec <HAL_RCC_OscConfig+0x94>
 8001ae4:	682b      	ldr	r3, [r5, #0]
 8001ae6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001aea:	e005      	b.n	8001af8 <HAL_RCC_OscConfig+0xa0>
 8001aec:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8001af0:	d108      	bne.n	8001b04 <HAL_RCC_OscConfig+0xac>
 8001af2:	682b      	ldr	r3, [r5, #0]
 8001af4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8001af8:	602b      	str	r3, [r5, #0]
 8001afa:	682b      	ldr	r3, [r5, #0]
 8001afc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001b00:	602b      	str	r3, [r5, #0]
 8001b02:	e008      	b.n	8001b16 <HAL_RCC_OscConfig+0xbe>
 8001b04:	682a      	ldr	r2, [r5, #0]
 8001b06:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001b0a:	602a      	str	r2, [r5, #0]
 8001b0c:	682a      	ldr	r2, [r5, #0]
 8001b0e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001b12:	602a      	str	r2, [r5, #0]
      
      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8001b14:	b16b      	cbz	r3, 8001b32 <HAL_RCC_OscConfig+0xda>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001b16:	f7ff fbd7 	bl	80012c8 <HAL_GetTick>
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001b1a:	4d78      	ldr	r5, [pc, #480]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
      
      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001b1c:	4606      	mov	r6, r0
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001b1e:	682b      	ldr	r3, [r5, #0]
 8001b20:	039f      	lsls	r7, r3, #14
 8001b22:	d49f      	bmi.n	8001a64 <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001b24:	f7ff fbd0 	bl	80012c8 <HAL_GetTick>
 8001b28:	1b80      	subs	r0, r0, r6
 8001b2a:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 8001b2e:	d9f6      	bls.n	8001b1e <HAL_RCC_OscConfig+0xc6>
 8001b30:	e7ce      	b.n	8001ad0 <HAL_RCC_OscConfig+0x78>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001b32:	f7ff fbc9 	bl	80012c8 <HAL_GetTick>
 8001b36:	4606      	mov	r6, r0
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001b38:	682b      	ldr	r3, [r5, #0]
 8001b3a:	0398      	lsls	r0, r3, #14
 8001b3c:	d592      	bpl.n	8001a64 <HAL_RCC_OscConfig+0xc>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001b3e:	f7ff fbc3 	bl	80012c8 <HAL_GetTick>
 8001b42:	1b80      	subs	r0, r0, r6
 8001b44:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 8001b48:	d9f6      	bls.n	8001b38 <HAL_RCC_OscConfig+0xe0>
 8001b4a:	e7c1      	b.n	8001ad0 <HAL_RCC_OscConfig+0x78>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 8001b4c:	4b6b      	ldr	r3, [pc, #428]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
 8001b4e:	689a      	ldr	r2, [r3, #8]
 8001b50:	f012 0f0c 	tst.w	r2, #12
 8001b54:	d007      	beq.n	8001b66 <HAL_RCC_OscConfig+0x10e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001b56:	689a      	ldr	r2, [r3, #8]
 8001b58:	f002 020c 	and.w	r2, r2, #12
 8001b5c:	2a08      	cmp	r2, #8
 8001b5e:	d117      	bne.n	8001b90 <HAL_RCC_OscConfig+0x138>
 8001b60:	685b      	ldr	r3, [r3, #4]
 8001b62:	0259      	lsls	r1, r3, #9
 8001b64:	d414      	bmi.n	8001b90 <HAL_RCC_OscConfig+0x138>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001b66:	4b65      	ldr	r3, [pc, #404]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
 8001b68:	681a      	ldr	r2, [r3, #0]
 8001b6a:	0792      	lsls	r2, r2, #30
 8001b6c:	d502      	bpl.n	8001b74 <HAL_RCC_OscConfig+0x11c>
 8001b6e:	68e2      	ldr	r2, [r4, #12]
 8001b70:	2a01      	cmp	r2, #1
 8001b72:	d190      	bne.n	8001a96 <HAL_RCC_OscConfig+0x3e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001b74:	681a      	ldr	r2, [r3, #0]
 8001b76:	21f8      	movs	r1, #248	; 0xf8
 8001b78:	fa91 f1a1 	rbit	r1, r1
 8001b7c:	6920      	ldr	r0, [r4, #16]
 8001b7e:	fab1 f181 	clz	r1, r1
 8001b82:	fa00 f101 	lsl.w	r1, r0, r1
 8001b86:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8001b8a:	430a      	orrs	r2, r1
 8001b8c:	601a      	str	r2, [r3, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001b8e:	e031      	b.n	8001bf4 <HAL_RCC_OscConfig+0x19c>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8001b90:	68e3      	ldr	r3, [r4, #12]
 8001b92:	4d5a      	ldr	r5, [pc, #360]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
 8001b94:	b1f3      	cbz	r3, 8001bd4 <HAL_RCC_OscConfig+0x17c>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001b96:	682b      	ldr	r3, [r5, #0]
 8001b98:	f043 0301 	orr.w	r3, r3, #1
 8001b9c:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001b9e:	f7ff fb93 	bl	80012c8 <HAL_GetTick>
 8001ba2:	4606      	mov	r6, r0

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001ba4:	682b      	ldr	r3, [r5, #0]
 8001ba6:	4855      	ldr	r0, [pc, #340]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
 8001ba8:	079f      	lsls	r7, r3, #30
 8001baa:	d405      	bmi.n	8001bb8 <HAL_RCC_OscConfig+0x160>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001bac:	f7ff fb8c 	bl	80012c8 <HAL_GetTick>
 8001bb0:	1b80      	subs	r0, r0, r6
 8001bb2:	2864      	cmp	r0, #100	; 0x64
 8001bb4:	d9f6      	bls.n	8001ba4 <HAL_RCC_OscConfig+0x14c>
 8001bb6:	e78b      	b.n	8001ad0 <HAL_RCC_OscConfig+0x78>
            return HAL_TIMEOUT;
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001bb8:	6803      	ldr	r3, [r0, #0]
 8001bba:	22f8      	movs	r2, #248	; 0xf8
 8001bbc:	fa92 f2a2 	rbit	r2, r2
 8001bc0:	6921      	ldr	r1, [r4, #16]
 8001bc2:	fab2 f282 	clz	r2, r2
 8001bc6:	fa01 f202 	lsl.w	r2, r1, r2
 8001bca:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8001bce:	4313      	orrs	r3, r2
 8001bd0:	6003      	str	r3, [r0, #0]
 8001bd2:	e00f      	b.n	8001bf4 <HAL_RCC_OscConfig+0x19c>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8001bd4:	682b      	ldr	r3, [r5, #0]
 8001bd6:	f023 0301 	bic.w	r3, r3, #1
 8001bda:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001bdc:	f7ff fb74 	bl	80012c8 <HAL_GetTick>
 8001be0:	4606      	mov	r6, r0
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001be2:	682b      	ldr	r3, [r5, #0]
 8001be4:	0799      	lsls	r1, r3, #30
 8001be6:	d505      	bpl.n	8001bf4 <HAL_RCC_OscConfig+0x19c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001be8:	f7ff fb6e 	bl	80012c8 <HAL_GetTick>
 8001bec:	1b80      	subs	r0, r0, r6
 8001bee:	2864      	cmp	r0, #100	; 0x64
 8001bf0:	d9f7      	bls.n	8001be2 <HAL_RCC_OscConfig+0x18a>
 8001bf2:	e76d      	b.n	8001ad0 <HAL_RCC_OscConfig+0x78>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001bf4:	6823      	ldr	r3, [r4, #0]
 8001bf6:	071a      	lsls	r2, r3, #28
 8001bf8:	d403      	bmi.n	8001c02 <HAL_RCC_OscConfig+0x1aa>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001bfa:	6823      	ldr	r3, [r4, #0]
 8001bfc:	075b      	lsls	r3, r3, #29
 8001bfe:	d567      	bpl.n	8001cd0 <HAL_RCC_OscConfig+0x278>
 8001c00:	e022      	b.n	8001c48 <HAL_RCC_OscConfig+0x1f0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8001c02:	6963      	ldr	r3, [r4, #20]
 8001c04:	4d3d      	ldr	r5, [pc, #244]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
 8001c06:	b17b      	cbz	r3, 8001c28 <HAL_RCC_OscConfig+0x1d0>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8001c08:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001c0a:	f043 0301 	orr.w	r3, r3, #1
 8001c0e:	676b      	str	r3, [r5, #116]	; 0x74
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001c10:	f7ff fb5a 	bl	80012c8 <HAL_GetTick>
 8001c14:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001c16:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001c18:	079f      	lsls	r7, r3, #30
 8001c1a:	d4ee      	bmi.n	8001bfa <HAL_RCC_OscConfig+0x1a2>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001c1c:	f7ff fb54 	bl	80012c8 <HAL_GetTick>
 8001c20:	1b80      	subs	r0, r0, r6
 8001c22:	2864      	cmp	r0, #100	; 0x64
 8001c24:	d9f7      	bls.n	8001c16 <HAL_RCC_OscConfig+0x1be>
 8001c26:	e753      	b.n	8001ad0 <HAL_RCC_OscConfig+0x78>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001c28:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001c2a:	f023 0301 	bic.w	r3, r3, #1
 8001c2e:	676b      	str	r3, [r5, #116]	; 0x74
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001c30:	f7ff fb4a 	bl	80012c8 <HAL_GetTick>
 8001c34:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001c36:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001c38:	0798      	lsls	r0, r3, #30
 8001c3a:	d5de      	bpl.n	8001bfa <HAL_RCC_OscConfig+0x1a2>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001c3c:	f7ff fb44 	bl	80012c8 <HAL_GetTick>
 8001c40:	1b80      	subs	r0, r0, r6
 8001c42:	2864      	cmp	r0, #100	; 0x64
 8001c44:	d9f7      	bls.n	8001c36 <HAL_RCC_OscConfig+0x1de>
 8001c46:	e743      	b.n	8001ad0 <HAL_RCC_OscConfig+0x78>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8001c48:	4b2c      	ldr	r3, [pc, #176]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
    
    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 8001c4a:	4d2d      	ldr	r5, [pc, #180]	; (8001d00 <HAL_RCC_OscConfig+0x2a8>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8001c4c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001c4e:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001c52:	641a      	str	r2, [r3, #64]	; 0x40
 8001c54:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001c56:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001c5a:	9301      	str	r3, [sp, #4]
 8001c5c:	9b01      	ldr	r3, [sp, #4]
    
    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 8001c5e:	682b      	ldr	r3, [r5, #0]
 8001c60:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001c64:	602b      	str	r3, [r5, #0]
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8001c66:	f7ff fb2f 	bl	80012c8 <HAL_GetTick>
 8001c6a:	4606      	mov	r6, r0
    
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8001c6c:	682b      	ldr	r3, [r5, #0]
 8001c6e:	05d9      	lsls	r1, r3, #23
 8001c70:	d531      	bpl.n	8001cd6 <HAL_RCC_OscConfig+0x27e>
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 8001c72:	4d22      	ldr	r5, [pc, #136]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
 8001c74:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001c76:	f023 0301 	bic.w	r3, r3, #1
 8001c7a:	672b      	str	r3, [r5, #112]	; 0x70
 8001c7c:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001c7e:	f023 0304 	bic.w	r3, r3, #4
 8001c82:	672b      	str	r3, [r5, #112]	; 0x70
 8001c84:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001c86:	f023 0301 	bic.w	r3, r3, #1
 8001c8a:	672b      	str	r3, [r5, #112]	; 0x70
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001c8c:	f7ff fb1c 	bl	80012c8 <HAL_GetTick>
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001c90:	462e      	mov	r6, r5
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001c92:	4607      	mov	r7, r0
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001c94:	f241 3888 	movw	r8, #5000	; 0x1388
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001c98:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8001c9a:	4d18      	ldr	r5, [pc, #96]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
 8001c9c:	079a      	lsls	r2, r3, #30
 8001c9e:	d420      	bmi.n	8001ce2 <HAL_RCC_OscConfig+0x28a>
        return HAL_TIMEOUT;
      }    
    } 
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001ca0:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001ca2:	f023 0301 	bic.w	r3, r3, #1
 8001ca6:	672b      	str	r3, [r5, #112]	; 0x70
 8001ca8:	68a3      	ldr	r3, [r4, #8]
 8001caa:	2b01      	cmp	r3, #1
 8001cac:	d11f      	bne.n	8001cee <HAL_RCC_OscConfig+0x296>
 8001cae:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001cb0:	f023 0304 	bic.w	r3, r3, #4
 8001cb4:	672b      	str	r3, [r5, #112]	; 0x70
 8001cb6:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001cb8:	f043 0301 	orr.w	r3, r3, #1
 8001cbc:	672b      	str	r3, [r5, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001cbe:	f7ff fb03 	bl	80012c8 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001cc2:	4d0e      	ldr	r5, [pc, #56]	; (8001cfc <HAL_RCC_OscConfig+0x2a4>)
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001cc4:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001cc6:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001cca:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001ccc:	079b      	lsls	r3, r3, #30
 8001cce:	d523      	bpl.n	8001d18 <HAL_RCC_OscConfig+0x2c0>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8001cd0:	69a2      	ldr	r2, [r4, #24]
 8001cd2:	bbaa      	cbnz	r2, 8001d40 <HAL_RCC_OscConfig+0x2e8>
 8001cd4:	e077      	b.n	8001dc6 <HAL_RCC_OscConfig+0x36e>
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8001cd6:	f7ff faf7 	bl	80012c8 <HAL_GetTick>
 8001cda:	1b80      	subs	r0, r0, r6
 8001cdc:	2864      	cmp	r0, #100	; 0x64
 8001cde:	d9c5      	bls.n	8001c6c <HAL_RCC_OscConfig+0x214>
 8001ce0:	e6f6      	b.n	8001ad0 <HAL_RCC_OscConfig+0x78>
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is ready */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001ce2:	f7ff faf1 	bl	80012c8 <HAL_GetTick>
 8001ce6:	1bc0      	subs	r0, r0, r7
 8001ce8:	4540      	cmp	r0, r8
 8001cea:	d9d5      	bls.n	8001c98 <HAL_RCC_OscConfig+0x240>
 8001cec:	e6f0      	b.n	8001ad0 <HAL_RCC_OscConfig+0x78>
        return HAL_TIMEOUT;
      }    
    } 
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001cee:	2b05      	cmp	r3, #5
 8001cf0:	d108      	bne.n	8001d04 <HAL_RCC_OscConfig+0x2ac>
 8001cf2:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001cf4:	f043 0304 	orr.w	r3, r3, #4
 8001cf8:	e7dc      	b.n	8001cb4 <HAL_RCC_OscConfig+0x25c>
 8001cfa:	bf00      	nop
 8001cfc:	40023800 	.word	0x40023800
 8001d00:	40007000 	.word	0x40007000
 8001d04:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8001d06:	f022 0204 	bic.w	r2, r2, #4
 8001d0a:	672a      	str	r2, [r5, #112]	; 0x70
 8001d0c:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8001d0e:	f022 0201 	bic.w	r2, r2, #1
 8001d12:	672a      	str	r2, [r5, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8001d14:	b133      	cbz	r3, 8001d24 <HAL_RCC_OscConfig+0x2cc>
 8001d16:	e7d2      	b.n	8001cbe <HAL_RCC_OscConfig+0x266>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001d18:	f7ff fad6 	bl	80012c8 <HAL_GetTick>
 8001d1c:	1b80      	subs	r0, r0, r6
 8001d1e:	42b8      	cmp	r0, r7
 8001d20:	d9d3      	bls.n	8001cca <HAL_RCC_OscConfig+0x272>
 8001d22:	e6d5      	b.n	8001ad0 <HAL_RCC_OscConfig+0x78>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001d24:	f7ff fad0 	bl	80012c8 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001d28:	f241 3788 	movw	r7, #5000	; 0x1388
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001d2c:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001d2e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001d30:	0798      	lsls	r0, r3, #30
 8001d32:	d5cd      	bpl.n	8001cd0 <HAL_RCC_OscConfig+0x278>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001d34:	f7ff fac8 	bl	80012c8 <HAL_GetTick>
 8001d38:	1b80      	subs	r0, r0, r6
 8001d3a:	42b8      	cmp	r0, r7
 8001d3c:	d9f7      	bls.n	8001d2e <HAL_RCC_OscConfig+0x2d6>
 8001d3e:	e6c7      	b.n	8001ad0 <HAL_RCC_OscConfig+0x78>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001d40:	4d2f      	ldr	r5, [pc, #188]	; (8001e00 <HAL_RCC_OscConfig+0x3a8>)
 8001d42:	68ab      	ldr	r3, [r5, #8]
 8001d44:	f003 030c 	and.w	r3, r3, #12
 8001d48:	2b08      	cmp	r3, #8
 8001d4a:	f43f aea4 	beq.w	8001a96 <HAL_RCC_OscConfig+0x3e>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001d4e:	682b      	ldr	r3, [r5, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001d50:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001d52:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8001d56:	602b      	str	r3, [r5, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001d58:	d143      	bne.n	8001de2 <HAL_RCC_OscConfig+0x38a>
        
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001d5a:	f7ff fab5 	bl	80012c8 <HAL_GetTick>
 8001d5e:	4607      	mov	r7, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001d60:	682b      	ldr	r3, [r5, #0]
 8001d62:	4e27      	ldr	r6, [pc, #156]	; (8001e00 <HAL_RCC_OscConfig+0x3a8>)
 8001d64:	0199      	lsls	r1, r3, #6
 8001d66:	d430      	bmi.n	8001dca <HAL_RCC_OscConfig+0x372>
 8001d68:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8001d6c:	fa92 f2a2 	rbit	r2, r2
 8001d70:	f44f 3340 	mov.w	r3, #196608	; 0x30000
            return HAL_TIMEOUT;
          }
        }
        
        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001d74:	fab2 f082 	clz	r0, r2
 8001d78:	fa93 f3a3 	rbit	r3, r3
 8001d7c:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
 8001d80:	fab3 f583 	clz	r5, r3
 8001d84:	fa92 f2a2 	rbit	r2, r2
 8001d88:	6a23      	ldr	r3, [r4, #32]
 8001d8a:	69e7      	ldr	r7, [r4, #28]
 8001d8c:	fab2 f182 	clz	r1, r2
 8001d90:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001d92:	431f      	orrs	r7, r3
 8001d94:	f047 5300 	orr.w	r3, r7, #536870912	; 0x20000000
 8001d98:	4082      	lsls	r2, r0
 8001d9a:	ea43 0002 	orr.w	r0, r3, r2
 8001d9e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001da0:	085a      	lsrs	r2, r3, #1
 8001da2:	3a01      	subs	r2, #1
 8001da4:	fa02 f305 	lsl.w	r3, r2, r5
 8001da8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001daa:	4303      	orrs	r3, r0
 8001dac:	408a      	lsls	r2, r1
 8001dae:	4313      	orrs	r3, r2
 8001db0:	6073      	str	r3, [r6, #4]
                             RCC_OscInitStruct->PLL.PLLM,
                             RCC_OscInitStruct->PLL.PLLN,
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8001db2:	6833      	ldr	r3, [r6, #0]
 8001db4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001db8:	6033      	str	r3, [r6, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001dba:	f7ff fa85 	bl	80012c8 <HAL_GetTick>
 8001dbe:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001dc0:	6833      	ldr	r3, [r6, #0]
 8001dc2:	019a      	lsls	r2, r3, #6
 8001dc4:	d507      	bpl.n	8001dd6 <HAL_RCC_OscConfig+0x37e>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8001dc6:	2000      	movs	r0, #0
 8001dc8:	e017      	b.n	8001dfa <HAL_RCC_OscConfig+0x3a2>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001dca:	f7ff fa7d 	bl	80012c8 <HAL_GetTick>
 8001dce:	1bc0      	subs	r0, r0, r7
 8001dd0:	2864      	cmp	r0, #100	; 0x64
 8001dd2:	d9c5      	bls.n	8001d60 <HAL_RCC_OscConfig+0x308>
 8001dd4:	e67c      	b.n	8001ad0 <HAL_RCC_OscConfig+0x78>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001dd6:	f7ff fa77 	bl	80012c8 <HAL_GetTick>
 8001dda:	1b00      	subs	r0, r0, r4
 8001ddc:	2864      	cmp	r0, #100	; 0x64
 8001dde:	d9ef      	bls.n	8001dc0 <HAL_RCC_OscConfig+0x368>
 8001de0:	e676      	b.n	8001ad0 <HAL_RCC_OscConfig+0x78>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001de2:	f7ff fa71 	bl	80012c8 <HAL_GetTick>
 8001de6:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001de8:	682b      	ldr	r3, [r5, #0]
 8001dea:	019b      	lsls	r3, r3, #6
 8001dec:	d5eb      	bpl.n	8001dc6 <HAL_RCC_OscConfig+0x36e>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001dee:	f7ff fa6b 	bl	80012c8 <HAL_GetTick>
 8001df2:	1b00      	subs	r0, r0, r4
 8001df4:	2864      	cmp	r0, #100	; 0x64
 8001df6:	d9f7      	bls.n	8001de8 <HAL_RCC_OscConfig+0x390>
 8001df8:	e66a      	b.n	8001ad0 <HAL_RCC_OscConfig+0x78>
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8001dfa:	b002      	add	sp, #8
 8001dfc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001e00:	40023800 	.word	0x40023800

08001e04 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
     must be correctly programmed according to the frequency of the CPU clock 
     (HCLK) and the supply voltage of the device. */
  
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001e04:	4a6c      	ldr	r2, [pc, #432]	; (8001fb8 <HAL_RCC_ClockConfig+0x1b4>)
 8001e06:	6813      	ldr	r3, [r2, #0]
 8001e08:	f003 030f 	and.w	r3, r3, #15
 8001e0c:	428b      	cmp	r3, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8001e0e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001e12:	4604      	mov	r4, r0
 8001e14:	460d      	mov	r5, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
     must be correctly programmed according to the frequency of the CPU clock 
     (HCLK) and the supply voltage of the device. */
  
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001e16:	d266      	bcs.n	8001ee6 <HAL_RCC_ClockConfig+0xe2>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001e18:	6813      	ldr	r3, [r2, #0]
 8001e1a:	f023 030f 	bic.w	r3, r3, #15
 8001e1e:	430b      	orrs	r3, r1
 8001e20:	6013      	str	r3, [r2, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001e22:	6813      	ldr	r3, [r2, #0]
 8001e24:	f003 030f 	and.w	r3, r3, #15
 8001e28:	4299      	cmp	r1, r3
 8001e2a:	d002      	beq.n	8001e32 <HAL_RCC_ClockConfig+0x2e>
    {
      return HAL_ERROR;
 8001e2c:	2001      	movs	r0, #1
 8001e2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001e32:	6801      	ldr	r1, [r0, #0]
 8001e34:	078f      	lsls	r7, r1, #30
 8001e36:	d506      	bpl.n	8001e46 <HAL_RCC_ClockConfig+0x42>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001e38:	4860      	ldr	r0, [pc, #384]	; (8001fbc <HAL_RCC_ClockConfig+0x1b8>)
 8001e3a:	6883      	ldr	r3, [r0, #8]
 8001e3c:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8001e40:	68a3      	ldr	r3, [r4, #8]
 8001e42:	4313      	orrs	r3, r2
 8001e44:	6083      	str	r3, [r0, #8]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/ 
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001e46:	07ce      	lsls	r6, r1, #31
 8001e48:	d40b      	bmi.n	8001e62 <HAL_RCC_ClockConfig+0x5e>
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001e4a:	6821      	ldr	r1, [r4, #0]
 8001e4c:	074d      	lsls	r5, r1, #29
 8001e4e:	f140 80a3 	bpl.w	8001f98 <HAL_RCC_ClockConfig+0x194>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001e52:	485a      	ldr	r0, [pc, #360]	; (8001fbc <HAL_RCC_ClockConfig+0x1b8>)
 8001e54:	6883      	ldr	r3, [r0, #8]
 8001e56:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 8001e5a:	68e3      	ldr	r3, [r4, #12]
 8001e5c:	4313      	orrs	r3, r2
 8001e5e:	6083      	str	r3, [r0, #8]
 8001e60:	e09a      	b.n	8001f98 <HAL_RCC_ClockConfig+0x194>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001e62:	6862      	ldr	r2, [r4, #4]
 8001e64:	4b55      	ldr	r3, [pc, #340]	; (8001fbc <HAL_RCC_ClockConfig+0x1b8>)
 8001e66:	2a01      	cmp	r2, #1
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001e68:	6819      	ldr	r1, [r3, #0]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001e6a:	d102      	bne.n	8001e72 <HAL_RCC_ClockConfig+0x6e>
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001e6c:	f411 3f00 	tst.w	r1, #131072	; 0x20000
 8001e70:	e006      	b.n	8001e80 <HAL_RCC_ClockConfig+0x7c>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001e72:	2a02      	cmp	r2, #2
 8001e74:	d102      	bne.n	8001e7c <HAL_RCC_ClockConfig+0x78>
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001e76:	f011 7f00 	tst.w	r1, #33554432	; 0x2000000
 8001e7a:	e001      	b.n	8001e80 <HAL_RCC_ClockConfig+0x7c>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001e7c:	f011 0f02 	tst.w	r1, #2
 8001e80:	d0d4      	beq.n	8001e2c <HAL_RCC_ClockConfig+0x28>
        {
          return HAL_ERROR;
        }
      }

      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001e82:	6899      	ldr	r1, [r3, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8001e84:	4e4d      	ldr	r6, [pc, #308]	; (8001fbc <HAL_RCC_ClockConfig+0x1b8>)
        {
          return HAL_ERROR;
        }
      }

      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001e86:	f021 0103 	bic.w	r1, r1, #3
 8001e8a:	430a      	orrs	r2, r1
 8001e8c:	609a      	str	r2, [r3, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001e8e:	f7ff fa1b 	bl	80012c8 <HAL_GetTick>
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001e92:	6863      	ldr	r3, [r4, #4]
 8001e94:	2b01      	cmp	r3, #1
        }
      }

      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001e96:	4605      	mov	r5, r0
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001e98:	f241 3788 	movw	r7, #5000	; 0x1388

      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001e9c:	d10c      	bne.n	8001eb8 <HAL_RCC_ClockConfig+0xb4>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8001e9e:	68b3      	ldr	r3, [r6, #8]
 8001ea0:	f003 030c 	and.w	r3, r3, #12
 8001ea4:	2b04      	cmp	r3, #4
 8001ea6:	d0d0      	beq.n	8001e4a <HAL_RCC_ClockConfig+0x46>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001ea8:	f7ff fa0e 	bl	80012c8 <HAL_GetTick>
 8001eac:	1b40      	subs	r0, r0, r5
 8001eae:	42b8      	cmp	r0, r7
 8001eb0:	d9f5      	bls.n	8001e9e <HAL_RCC_ClockConfig+0x9a>
          {
            return HAL_TIMEOUT;
 8001eb2:	2003      	movs	r0, #3
 8001eb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001eb8:	2b02      	cmp	r3, #2
 8001eba:	d10f      	bne.n	8001edc <HAL_RCC_ClockConfig+0xd8>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001ebc:	68b3      	ldr	r3, [r6, #8]
 8001ebe:	f003 030c 	and.w	r3, r3, #12
 8001ec2:	2b08      	cmp	r3, #8
 8001ec4:	d0c1      	beq.n	8001e4a <HAL_RCC_ClockConfig+0x46>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001ec6:	f7ff f9ff 	bl	80012c8 <HAL_GetTick>
 8001eca:	1b40      	subs	r0, r0, r5
 8001ecc:	42b8      	cmp	r0, r7
 8001ece:	d9f5      	bls.n	8001ebc <HAL_RCC_ClockConfig+0xb8>
 8001ed0:	e7ef      	b.n	8001eb2 <HAL_RCC_ClockConfig+0xae>
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001ed2:	f7ff f9f9 	bl	80012c8 <HAL_GetTick>
 8001ed6:	1b40      	subs	r0, r0, r5
 8001ed8:	42b8      	cmp	r0, r7
 8001eda:	d8ea      	bhi.n	8001eb2 <HAL_RCC_ClockConfig+0xae>
          }
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8001edc:	68b3      	ldr	r3, [r6, #8]
 8001ede:	f013 0f0c 	tst.w	r3, #12
 8001ee2:	d1f6      	bne.n	8001ed2 <HAL_RCC_ClockConfig+0xce>
 8001ee4:	e7b1      	b.n	8001e4a <HAL_RCC_ClockConfig+0x46>
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001ee6:	6801      	ldr	r1, [r0, #0]
 8001ee8:	0788      	lsls	r0, r1, #30
 8001eea:	d506      	bpl.n	8001efa <HAL_RCC_ClockConfig+0xf6>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001eec:	4833      	ldr	r0, [pc, #204]	; (8001fbc <HAL_RCC_ClockConfig+0x1b8>)
 8001eee:	6883      	ldr	r3, [r0, #8]
 8001ef0:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8001ef4:	68a3      	ldr	r3, [r4, #8]
 8001ef6:	4313      	orrs	r3, r2
 8001ef8:	6083      	str	r3, [r0, #8]
    }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001efa:	07ca      	lsls	r2, r1, #31
 8001efc:	d40b      	bmi.n	8001f16 <HAL_RCC_ClockConfig+0x112>
        }
      }
    }
    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001efe:	4a2e      	ldr	r2, [pc, #184]	; (8001fb8 <HAL_RCC_ClockConfig+0x1b4>)
 8001f00:	6813      	ldr	r3, [r2, #0]
 8001f02:	f023 030f 	bic.w	r3, r3, #15
 8001f06:	432b      	orrs	r3, r5
 8001f08:	6013      	str	r3, [r2, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001f0a:	6813      	ldr	r3, [r2, #0]
 8001f0c:	f003 030f 	and.w	r3, r3, #15
 8001f10:	429d      	cmp	r5, r3
 8001f12:	d18b      	bne.n	8001e2c <HAL_RCC_ClockConfig+0x28>
 8001f14:	e799      	b.n	8001e4a <HAL_RCC_ClockConfig+0x46>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001f16:	6862      	ldr	r2, [r4, #4]
 8001f18:	4b28      	ldr	r3, [pc, #160]	; (8001fbc <HAL_RCC_ClockConfig+0x1b8>)
 8001f1a:	2a01      	cmp	r2, #1
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001f1c:	6819      	ldr	r1, [r3, #0]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001f1e:	d102      	bne.n	8001f26 <HAL_RCC_ClockConfig+0x122>
      {
        /* Check the HSE ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001f20:	f411 3f00 	tst.w	r1, #131072	; 0x20000
 8001f24:	e006      	b.n	8001f34 <HAL_RCC_ClockConfig+0x130>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001f26:	2a02      	cmp	r2, #2
 8001f28:	d102      	bne.n	8001f30 <HAL_RCC_ClockConfig+0x12c>
      {
        /* Check the PLL ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001f2a:	f011 7f00 	tst.w	r1, #33554432	; 0x2000000
 8001f2e:	e001      	b.n	8001f34 <HAL_RCC_ClockConfig+0x130>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001f30:	f011 0f02 	tst.w	r1, #2
 8001f34:	f43f af7a 	beq.w	8001e2c <HAL_RCC_ClockConfig+0x28>
        {
          return HAL_ERROR;
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001f38:	6899      	ldr	r1, [r3, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8001f3a:	4f20      	ldr	r7, [pc, #128]	; (8001fbc <HAL_RCC_ClockConfig+0x1b8>)
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
        {
          return HAL_ERROR;
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001f3c:	f021 0103 	bic.w	r1, r1, #3
 8001f40:	430a      	orrs	r2, r1
 8001f42:	609a      	str	r2, [r3, #8]
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001f44:	f7ff f9c0 	bl	80012c8 <HAL_GetTick>
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001f48:	6863      	ldr	r3, [r4, #4]
 8001f4a:	2b01      	cmp	r3, #1
          return HAL_ERROR;
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001f4c:	4606      	mov	r6, r0
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001f4e:	f241 3888 	movw	r8, #5000	; 0x1388
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001f52:	d10a      	bne.n	8001f6a <HAL_RCC_ClockConfig+0x166>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8001f54:	68bb      	ldr	r3, [r7, #8]
 8001f56:	f003 030c 	and.w	r3, r3, #12
 8001f5a:	2b04      	cmp	r3, #4
 8001f5c:	d0cf      	beq.n	8001efe <HAL_RCC_ClockConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001f5e:	f7ff f9b3 	bl	80012c8 <HAL_GetTick>
 8001f62:	1b80      	subs	r0, r0, r6
 8001f64:	4540      	cmp	r0, r8
 8001f66:	d9f5      	bls.n	8001f54 <HAL_RCC_ClockConfig+0x150>
 8001f68:	e7a3      	b.n	8001eb2 <HAL_RCC_ClockConfig+0xae>
          {
            return HAL_TIMEOUT;
          } 
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001f6a:	2b02      	cmp	r3, #2
 8001f6c:	d10f      	bne.n	8001f8e <HAL_RCC_ClockConfig+0x18a>
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001f6e:	68bb      	ldr	r3, [r7, #8]
 8001f70:	f003 030c 	and.w	r3, r3, #12
 8001f74:	2b08      	cmp	r3, #8
 8001f76:	d0c2      	beq.n	8001efe <HAL_RCC_ClockConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001f78:	f7ff f9a6 	bl	80012c8 <HAL_GetTick>
 8001f7c:	1b80      	subs	r0, r0, r6
 8001f7e:	4540      	cmp	r0, r8
 8001f80:	d9f5      	bls.n	8001f6e <HAL_RCC_ClockConfig+0x16a>
 8001f82:	e796      	b.n	8001eb2 <HAL_RCC_ClockConfig+0xae>
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001f84:	f7ff f9a0 	bl	80012c8 <HAL_GetTick>
 8001f88:	1b80      	subs	r0, r0, r6
 8001f8a:	4540      	cmp	r0, r8
 8001f8c:	d891      	bhi.n	8001eb2 <HAL_RCC_ClockConfig+0xae>
          } 
        }
      }
      else
      {
        while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8001f8e:	68bb      	ldr	r3, [r7, #8]
 8001f90:	f013 0f0c 	tst.w	r3, #12
 8001f94:	d1f6      	bne.n	8001f84 <HAL_RCC_ClockConfig+0x180>
 8001f96:	e7b2      	b.n	8001efe <HAL_RCC_ClockConfig+0xfa>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001f98:	070b      	lsls	r3, r1, #28
 8001f9a:	d507      	bpl.n	8001fac <HAL_RCC_ClockConfig+0x1a8>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8001f9c:	4a07      	ldr	r2, [pc, #28]	; (8001fbc <HAL_RCC_ClockConfig+0x1b8>)
 8001f9e:	6921      	ldr	r1, [r4, #16]
 8001fa0:	6893      	ldr	r3, [r2, #8]
 8001fa2:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8001fa6:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001faa:	6093      	str	r3, [r2, #8]
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8001fac:	200f      	movs	r0, #15
 8001fae:	f7ff f95f 	bl	8001270 <HAL_InitTick>
  
  return HAL_OK;
 8001fb2:	2000      	movs	r0, #0
}
 8001fb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001fb8:	40023c00 	.word	0x40023c00
 8001fbc:	40023800 	.word	0x40023800

08001fc0 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001fc0:	491b      	ldr	r1, [pc, #108]	; (8002030 <HAL_RCC_GetSysClockFreq+0x70>)
 8001fc2:	688b      	ldr	r3, [r1, #8]
 8001fc4:	f003 030c 	and.w	r3, r3, #12
 8001fc8:	2b04      	cmp	r3, #4
 8001fca:	d02c      	beq.n	8002026 <HAL_RCC_GetSysClockFreq+0x66>
 8001fcc:	2b08      	cmp	r3, #8
 8001fce:	d12c      	bne.n	800202a <HAL_RCC_GetSysClockFreq+0x6a>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001fd0:	6848      	ldr	r0, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8001fd2:	684b      	ldr	r3, [r1, #4]
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001fd4:	f000 003f 	and.w	r0, r0, #63	; 0x3f
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8001fd8:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8001fdc:	f647 72c0 	movw	r2, #32704	; 0x7fc0
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8001fe0:	684b      	ldr	r3, [r1, #4]
 8001fe2:	fa92 f2a2 	rbit	r2, r2
 8001fe6:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8001fea:	fab2 f282 	clz	r2, r2
 8001fee:	ea01 0103 	and.w	r1, r1, r3
 8001ff2:	fa21 f102 	lsr.w	r1, r1, r2
 8001ff6:	bf14      	ite	ne
 8001ff8:	4a0e      	ldrne	r2, [pc, #56]	; (8002034 <HAL_RCC_GetSysClockFreq+0x74>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8001ffa:	4a0f      	ldreq	r2, [pc, #60]	; (8002038 <HAL_RCC_GetSysClockFreq+0x78>)
 8001ffc:	fbb2 f0f0 	udiv	r0, r2, r0
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 8002000:	4a0b      	ldr	r2, [pc, #44]	; (8002030 <HAL_RCC_GetSysClockFreq+0x70>)
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8002002:	fb00 f301 	mul.w	r3, r0, r1
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 8002006:	6852      	ldr	r2, [r2, #4]
 8002008:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 800200c:	fa90 f0a0 	rbit	r0, r0
      
      sysclockfreq = pllvco/pllp;
 8002010:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 8002014:	fab0 f080 	clz	r0, r0
      
      sysclockfreq = pllvco/pllp;
 8002018:	fa22 f000 	lsr.w	r0, r2, r0
 800201c:	3001      	adds	r0, #1
 800201e:	0040      	lsls	r0, r0, #1
 8002020:	fbb3 f0f0 	udiv	r0, r3, r0
 8002024:	4770      	bx	lr
      sysclockfreq = HSI_VALUE;
       break;
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8002026:	4803      	ldr	r0, [pc, #12]	; (8002034 <HAL_RCC_GetSysClockFreq+0x74>)
 8002028:	4770      	bx	lr
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 800202a:	4803      	ldr	r0, [pc, #12]	; (8002038 <HAL_RCC_GetSysClockFreq+0x78>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 800202c:	4770      	bx	lr
 800202e:	bf00      	nop
 8002030:	40023800 	.word	0x40023800
 8002034:	007a1200 	.word	0x007a1200
 8002038:	00f42400 	.word	0x00f42400

0800203c <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800203c:	b508      	push	{r3, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 800203e:	f7ff ffbf 	bl	8001fc0 <HAL_RCC_GetSysClockFreq>
 8002042:	4b08      	ldr	r3, [pc, #32]	; (8002064 <HAL_RCC_GetHCLKFreq+0x28>)
 8002044:	22f0      	movs	r2, #240	; 0xf0
 8002046:	689b      	ldr	r3, [r3, #8]
 8002048:	fa92 f2a2 	rbit	r2, r2
 800204c:	fab2 f282 	clz	r2, r2
 8002050:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8002054:	40d3      	lsrs	r3, r2
 8002056:	4a04      	ldr	r2, [pc, #16]	; (8002068 <HAL_RCC_GetHCLKFreq+0x2c>)
 8002058:	5cd3      	ldrb	r3, [r2, r3]
 800205a:	40d8      	lsrs	r0, r3
 800205c:	4b03      	ldr	r3, [pc, #12]	; (800206c <HAL_RCC_GetHCLKFreq+0x30>)
 800205e:	6018      	str	r0, [r3, #0]
  return SystemCoreClock;
}
 8002060:	bd08      	pop	{r3, pc}
 8002062:	bf00      	nop
 8002064:	40023800 	.word	0x40023800
 8002068:	08002343 	.word	0x08002343
 800206c:	20000000 	.word	0x20000000

08002070 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
 8002070:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 8002072:	f7ff ffe3 	bl	800203c <HAL_RCC_GetHCLKFreq>
 8002076:	4b07      	ldr	r3, [pc, #28]	; (8002094 <HAL_RCC_GetPCLK1Freq+0x24>)
 8002078:	f44f 52e0 	mov.w	r2, #7168	; 0x1c00
 800207c:	689b      	ldr	r3, [r3, #8]
 800207e:	fa92 f2a2 	rbit	r2, r2
 8002082:	fab2 f282 	clz	r2, r2
 8002086:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 800208a:	40d3      	lsrs	r3, r2
 800208c:	4a02      	ldr	r2, [pc, #8]	; (8002098 <HAL_RCC_GetPCLK1Freq+0x28>)
 800208e:	5cd3      	ldrb	r3, [r2, r3]
}
 8002090:	40d8      	lsrs	r0, r3
 8002092:	bd08      	pop	{r3, pc}
 8002094:	40023800 	.word	0x40023800
 8002098:	08002343 	.word	0x08002343

0800209c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800209c:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 800209e:	f7ff ffcd 	bl	800203c <HAL_RCC_GetHCLKFreq>
 80020a2:	4b07      	ldr	r3, [pc, #28]	; (80020c0 <HAL_RCC_GetPCLK2Freq+0x24>)
 80020a4:	f44f 4260 	mov.w	r2, #57344	; 0xe000
 80020a8:	689b      	ldr	r3, [r3, #8]
 80020aa:	fa92 f2a2 	rbit	r2, r2
 80020ae:	fab2 f282 	clz	r2, r2
 80020b2:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 80020b6:	40d3      	lsrs	r3, r2
 80020b8:	4a02      	ldr	r2, [pc, #8]	; (80020c4 <HAL_RCC_GetPCLK2Freq+0x28>)
 80020ba:	5cd3      	ldrb	r3, [r2, r3]
} 
 80020bc:	40d8      	lsrs	r0, r3
 80020be:	bd08      	pop	{r3, pc}
 80020c0:	40023800 	.word	0x40023800
 80020c4:	08002343 	.word	0x08002343

080020c8 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80020c8:	490f      	ldr	r1, [pc, #60]	; (8002108 <SystemInit+0x40>)
 80020ca:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 80020ce:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80020d2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80020d6:	4b0d      	ldr	r3, [pc, #52]	; (800210c <SystemInit+0x44>)
 80020d8:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80020da:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80020dc:	f042 0201 	orr.w	r2, r2, #1
 80020e0:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80020e2:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80020e4:	681a      	ldr	r2, [r3, #0]
 80020e6:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80020ea:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80020ee:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80020f0:	4a07      	ldr	r2, [pc, #28]	; (8002110 <SystemInit+0x48>)
 80020f2:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80020f4:	681a      	ldr	r2, [r3, #0]
 80020f6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80020fa:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80020fc:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80020fe:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8002102:	608b      	str	r3, [r1, #8]
 8002104:	4770      	bx	lr
 8002106:	bf00      	nop
 8002108:	e000ed00 	.word	0xe000ed00
 800210c:	40023800 	.word	0x40023800
 8002110:	24003010 	.word	0x24003010

Disassembly of section .data:

20000000 <SystemCoreClock>:
20000000:	00f42400 00000000                       .$......

Disassembly of section .bss:

20000008 <__bss_start__>:
	...

2000000a <max>:
	...

2000000c <sum>:
2000000c:	00000000                                ....

20000010 <_work>:
	...

20001f50 <data>:
	...

20003e90 <ix>:
20003e90:	00000000                                ....

20003e94 <uwTick>:
20003e94:	00000000                                ....

20003e98 <adc_hdl>:
	...

20003edc <yin>:
	...

20003eec <__uart_vec>:
	...
